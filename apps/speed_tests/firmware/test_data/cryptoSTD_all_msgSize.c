/* cryptoSTD_all_msgSize

  Crypto Speed Test Data File

  Company:
    Microchip Technology Inc.

  Description:
  This package provides test cases for many algorithms
  to measure performance with different input sizes.
*/

//DOM-IGNORE-BEGIN
/*****************************************************************************
 Copyright (C) 2013-2020 Microchip Technology Inc. and its subsidiaries.

Microchip Technology Inc. and its subsidiaries.

Subject to your compliance with these terms, you may use Microchip software 
and any derivatives exclusively with Microchip products. It is your 
responsibility to comply with third party license terms applicable to your 
use of third party software (including open source software) that may 
accompany Microchip software.

THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED 
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR 
PURPOSE.

IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS 
BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE 
FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN 
ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, 
THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
*****************************************************************************/

//DOM-IGNORE-END

#include <stdint.h>
#include "./cryptoSpeedTestData.h"
#include "cryptoST/cryptoSTE_generate.h"
#include "cryptoST/cryptoSTE_malloc.h"
#include "cryptoST/cryptoSTE_print.h"
#include "cryptoSTD_rsa_CAVS16p1_RSASP1.h"
#include "app.h" // for BASE_LINE
#include <wolfssl/wolfcrypt/hash.h>
#include <wolfssl/wolfcrypt/aes.h>

#define DATA_PACKAGE_NAME "ALL_MSG_SZ"

/*************************************************************
 * Data limit definitions.
 *************************************************************/
#define ZERO_MIN    (8)
#if defined(NO_RSA) // smaller parts (L21 and L11) can't malloc 10k
#define ZERO_MAX    (512*2)
#else
#define ZERO_MAX    (10 * 1024)
#endif

/*************************************************************
 * Raw (input) data definitions for run-time defined
 * sequential and random data sets having large block sizes.
 *************************************************************/
static cryptoST_testVector_t satcZ =
{
    .name = DATA_PACKAGE_NAME "_NULL",
    .source = "Microchip",
    .description = "Pseudo-generated data sets of various sizes",
    .vector.data = NULL, // fill this in later using malloc
    .vector.length = 0,  // and this, too
};
/*************************************************************
 * Golden data definitions.
 *************************************************************/
static uint8_t sramBuffer[32] = { 0 };
#define ASIZE(a) ((sizeof(a)/sizeof(a[0])))

#define ALIGN4 __attribute__((aligned(4)))
#define DATA_CHAR ALIGN4 const uint8_t

#if !defined(NO_RSA)
const cryptoST_testData_t der1024 = {
    .length = 608,
    .data = (DATA_CHAR[608]){
0x30,0x82,0x02,0x5C,0x02,0x01,0x00,0x02,0x81,0x81,0x00,0xC3,0x3A,0xE0,0x56,0xF1,
0x96,0xD9,0x68,0xDE,0x4E,0x54,0x36,0xEC,0x62,0x99,0xE6,0x4D,0x9A,0xBD,0xEA,0xD6,
0xC8,0x37,0xA7,0x9D,0xF9,0x9A,0x2A,0xEC,0x41,0xA0,0xD9,0x25,0x96,0xF9,0x2F,0xC6,
0xC2,0x2A,0x37,0xA3,0x8A,0x98,0x89,0x76,0xAB,0x1A,0x71,0x06,0xFB,0xB6,0x53,0x26,
0x46,0x22,0x80,0xE2,0x1D,0xF2,0xAE,0x88,0xB7,0x32,0x97,0x84,0x5B,0x27,0x04,0xEC,
0x71,0x3D,0x5E,0x16,0x4D,0x2F,0xD5,0x26,0x05,0x8D,0xA2,0x0E,0xB0,0xF6,0x82,0x86,
0x9F,0x2D,0x40,0x7A,0xFB,0xD5,0x08,0x96,0xCC,0x77,0xE7,0x88,0x0D,0x7C,0x61,0x50,
0x61,0x90,0xEF,0xAF,0xBE,0x19,0x52,0xD6,0x04,0xE9,0x44,0x65,0x76,0xFB,0x21,0xEB,
0xA2,0xA3,0x7B,0xEE,0xF1,0x49,0x59,0x25,0xC7,0x05,0x23,0x02,0x03,0x01,0x00,0x01,
0x02,0x81,0x80,0x70,0xE5,0x39,0x19,0xCD,0xF6,0xD7,0x9E,0x46,0xFF,0xB0,0xBF,0x5A,
0x0E,0xE2,0xC4,0x45,0x18,0x38,0xBE,0xF6,0x99,0x2D,0x65,0xE6,0x7A,0x92,0x66,0x43,
0xDC,0xE7,0xB0,0xEA,0x85,0xD5,0x6F,0x85,0x56,0x7E,0xA7,0x52,0x11,0x31,0x88,0x3C,
0x71,0x51,0x87,0x0E,0xEC,0xBC,0x50,0x75,0x0F,0x95,0xA0,0x46,0x21,0xDF,0x56,0x82,
0x84,0xBD,0xE1,0xCF,0xBD,0x98,0x6D,0xA5,0x66,0x82,0x27,0xD4,0xB6,0x86,0x76,0x94,
0x57,0x03,0x2E,0x81,0x71,0xA4,0x2B,0x2A,0xF0,0x7F,0x43,0x67,0x16,0xA6,0x51,0x0C,
0xC6,0xC9,0xFF,0x89,0x7A,0x2C,0x1F,0x74,0x5D,0xE4,0x6A,0x83,0x7C,0x5F,0xAC,0x93,
0x31,0x0E,0xA2,0x4B,0x7B,0x29,0x22,0x7B,0xA4,0xFA,0xEC,0x79,0x87,0xC6,0x64,0x15,
0x25,0xAA,0x31,0x02,0x41,0x00,0xFF,0x1A,0x17,0x78,0x39,0xAD,0x88,0xE3,0xF2,0xF4,
0x8D,0x6E,0x54,0x4C,0x8C,0x71,0x4D,0x31,0x11,0x3E,0xAF,0x15,0xC7,0x04,0x53,0xCB,
0xB4,0xE7,0x79,0x67,0x84,0x19,0x86,0x38,0x23,0xD4,0xD4,0xDE,0x0C,0x10,0x7F,0x0B,
0x33,0x65,0x28,0xF7,0xB0,0x44,0x3B,0xE8,0xA0,0x29,0xCD,0x01,0xFA,0x47,0xBB,0x3F,
0x6D,0x67,0x1C,0x16,0x4F,0x17,0x02,0x41,0x00,0xC3,0xEA,0xD3,0x5A,0xB9,0xE5,0x8C,
0xE7,0x77,0xDC,0xAF,0xA9,0x33,0xA1,0xCC,0x3C,0x16,0x23,0x6F,0xA4,0x56,0x04,0xE4,
0x75,0x87,0x06,0xF6,0xF7,0x71,0x58,0xA3,0xBA,0xA3,0x2F,0x45,0x53,0x9D,0xA4,0xEF,
0xF6,0x63,0x31,0x69,0x36,0x31,0x08,0x66,0x99,0xE0,0xB3,0x5A,0xDD,0x11,0x45,0x16,
0x31,0x3D,0x7C,0xDF,0xA9,0x62,0x6C,0xE1,0xD5,0x02,0x40,0x7D,0xCE,0x20,0x44,0xEA,
0x2C,0xEA,0x95,0x7F,0xFB,0x9A,0xC4,0x0E,0x4E,0xB1,0xF4,0x2E,0x5D,0x44,0x63,0xE5,
0x74,0x97,0xF1,0x4A,0x61,0xEB,0x95,0x3C,0x0A,0x10,0xDB,0x85,0x95,0xAA,0x16,0x0B,
0xE4,0x75,0x8E,0xAD,0x18,0x99,0x00,0x0A,0x74,0x1C,0x39,0x8A,0x51,0xEE,0xAA,0xAE,
0xAF,0x8A,0xFE,0x55,0x19,0xB2,0x9A,0x66,0xFF,0x99,0x81,0x02,0x41,0x00,0xC2,0x6C,
0x2E,0x34,0x91,0xD8,0xA0,0x9D,0x30,0x10,0xDC,0x6D,0xF0,0x64,0x37,0x76,0xC5,0x8D,
0x83,0x04,0x35,0xAD,0x03,0x3F,0x32,0xB1,0x91,0xB2,0x7B,0x54,0x38,0x9F,0x45,0xC3,
0xEA,0x6B,0x91,0x3D,0x16,0x39,0x8F,0xB4,0x80,0x31,0x9C,0x35,0x37,0x04,0xAB,0xBD,
0xB1,0x85,0x42,0xD7,0x29,0xAF,0xD1,0xD2,0x33,0x6F,0x37,0xD2,0xCF,0xC5,0x02,0x40,
0x36,0x7D,0x67,0x23,0xDA,0xB9,0xFD,0x37,0x11,0xD7,0xF2,0xEA,0xDF,0x2F,0xAA,0xD9,
0xD0,0xB9,0x75,0x03,0xA9,0x72,0xF2,0x26,0xE5,0x10,0x99,0xA5,0xA0,0xA7,0xAA,0x63,
0x6D,0xDE,0x34,0xE0,0x87,0x2E,0x3E,0x3B,0xA6,0xF2,0xC2,0x61,0x97,0xA6,0x6C,0x87,
0x6F,0x60,0x34,0x95,0x0A,0x91,0xC1,0x54,0x8D,0xFD,0xE5,0xCB,0x48,0xFC,0x3F,0xA1,    
    }
};

cryptoST_testData_t sig1024 = {
    .length = 128,
    .data = (DATA_CHAR[128]){
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    }
};

const cryptoST_testData_t der2048 = {
    .length = 1190,
    .data = (DATA_CHAR[1190]){
0x30,0x82,0x04,0xA2,0x02,0x01,0x00,0x02,0x82,0x01,0x01,0x00,0xBC,0xB1,0xFC,0x15,
0x65,0x14,0xE0,0x5B,0xE5,0xDF,0x2E,0x77,0xBC,0x47,0x3F,0xE6,0xEC,0x92,0x99,0x9E,
0xB6,0x51,0xA4,0xC6,0x53,0x67,0x32,0x5A,0xF4,0x5B,0x07,0x44,0x21,0x50,0x4A,0xE0,
0x32,0xC5,0x85,0x86,0xCD,0x93,0xD4,0x48,0x35,0xF2,0x89,0xF7,0x79,0x76,0x19,0x75,
0x44,0xED,0x97,0x70,0xA1,0xF0,0xC3,0xDE,0xEA,0x69,0xD3,0x85,0x6E,0xAA,0x47,0x7C,
0x52,0xE7,0x94,0x1B,0x93,0x97,0x62,0x72,0x36,0x4B,0x2F,0x4C,0x06,0x5C,0x51,0x96,
0xFB,0xA9,0xE9,0x33,0xA4,0xA2,0xAA,0x14,0xB2,0xC6,0x02,0x2E,0x31,0x14,0xFE,0xB9,
0x17,0xC8,0xFE,0x8D,0xC5,0x91,0xFD,0xB3,0x68,0xC1,0x2C,0x3E,0xCC,0xC3,0x73,0x88,
0x73,0x99,0xF6,0xB7,0xD4,0xCD,0x2D,0x91,0xAC,0xDA,0xDE,0xC1,0x9E,0xAD,0x37,0x3B,
0xE1,0x35,0x8D,0x03,0x57,0x0F,0x7A,0x5A,0x60,0xA5,0x25,0x08,0x2B,0x82,0x7F,0x55,
0x70,0xBC,0x34,0xE5,0xFC,0xA8,0xA6,0x72,0x6D,0x57,0xD0,0x0B,0x9C,0x3E,0x99,0xB8,
0xE6,0x76,0x9F,0x50,0x33,0x55,0x8B,0x8D,0x1D,0x4F,0xC3,0x71,0x96,0xF1,0x92,0x8C,
0x45,0x76,0x47,0x1B,0x11,0x69,0xF4,0x53,0xCD,0x8B,0x5E,0x99,0x61,0xC2,0xC7,0x25,
0x9F,0xD4,0xF1,0xD0,0xE3,0x84,0xE7,0xF6,0x0D,0x89,0xDA,0xE0,0x8E,0x3A,0x06,0x5D,
0x0C,0x0D,0x9A,0xE1,0xAC,0x87,0x31,0xC6,0x38,0xB4,0xC7,0x4E,0x46,0x36,0x89,0x22,
0x4B,0x1D,0x0B,0xCB,0x9B,0x38,0x4C,0xBE,0x55,0x20,0x95,0xF2,0xF2,0xDE,0xA0,0x43,
0x06,0x96,0x9A,0x36,0xD3,0x99,0xE4,0xE2,0xF0,0x21,0x41,0xDF,0x02,0x03,0x01,0x00,
0x01,0x02,0x82,0x01,0x00,0x6A,0x04,0x01,0xE2,0xAF,0x61,0x14,0x50,0xED,0x8D,0x00,
0x19,0x8B,0xB1,0xE8,0x48,0x41,0x00,0x78,0xC9,0x00,0x1C,0x4C,0xDC,0x94,0xBD,0x75,
0x40,0x3E,0xEB,0xE9,0xE0,0x30,0x6B,0x61,0x36,0x27,0xB0,0x6C,0x3D,0xF9,0xC0,0xA5,
0xD3,0x50,0x64,0x0D,0x79,0xFA,0x47,0x0D,0x34,0xA2,0xDE,0x6E,0x68,0x7C,0xC3,0xBD,
0xF8,0xBF,0x71,0x67,0xC3,0x1F,0x13,0x12,0x88,0xDA,0x37,0x7C,0x32,0x26,0x31,0x36,
0xC1,0x7E,0x99,0xAD,0x60,0x24,0x6E,0xB7,0xF4,0x81,0x3E,0xCC,0x64,0x14,0x8A,0xC3,
0xCE,0x4F,0x47,0x0A,0xB0,0x93,0x28,0xFD,0x98,0x56,0xB1,0xB9,0xBB,0x43,0x96,0xAB,
0x98,0xA2,0x31,0x6E,0x3F,0x76,0x62,0x15,0xC6,0x43,0x54,0xEC,0x96,0x0A,0x3C,0xA0,
0xEE,0xA8,0xD4,0x6B,0xB4,0x1C,0x0F,0x0E,0x54,0x7E,0x8D,0xAD,0x7A,0xDE,0xDA,0x8C,
0x2A,0xB6,0x1C,0xD2,0xC4,0xC2,0xD2,0x65,0x68,0xB2,0xAD,0xC3,0x70,0x29,0x55,0xCF,
0x1C,0xA8,0x9B,0x54,0x10,0xF4,0x26,0x79,0x7B,0xE3,0xA3,0x2A,0x57,0xF0,0x8E,0x2B,
0x9F,0x13,0xC3,0xE2,0xC5,0xAB,0xC0,0xFD,0xAC,0xC1,0x59,0xE3,0x28,0xEA,0x16,0x54,
0xFB,0x21,0x36,0xAD,0x60,0xFB,0x43,0xB7,0x60,0x0F,0xE5,0x6F,0x23,0x4A,0x7C,0x25,
0xF2,0xCD,0x46,0xC9,0x63,0xCB,0x14,0xD5,0xC1,0x50,0x8E,0x8C,0x79,0x5E,0x20,0x66,
0xBC,0x86,0x26,0x57,0xD9,0x80,0x55,0xDD,0x87,0xF1,0xDB,0xCC,0xDE,0x50,0x46,0x56,
0x23,0x8A,0x01,0x9C,0x01,0xD0,0x98,0x14,0x32,0x7A,0xA3,0x6F,0x9E,0xCC,0xFA,0x6B,
0x7F,0xE6,0x8E,0xAE,0x01,0x02,0x81,0x81,0x00,0xDB,0xF2,0xCB,0x2E,0x60,0x30,0x3C,
0x4F,0xCB,0x4A,0x23,0x76,0x28,0xAE,0x2F,0xC0,0x23,0x46,0x11,0xBD,0xD2,0x29,0xBB,
0x88,0x1A,0x85,0x82,0xB0,0xDC,0xE5,0xA3,0x80,0x74,0xC1,0x7C,0x7E,0x0D,0x9A,0x7A,
0x33,0xED,0x20,0x0E,0xEC,0x35,0x1A,0x8E,0x1C,0x4C,0x87,0xB7,0xA7,0x94,0xCF,0xFE,
0x38,0xF8,0x58,0xF5,0xE8,0xC1,0xC7,0x91,0x9D,0xAF,0xAC,0x66,0x9D,0x2C,0x0A,0x3A,
0xEE,0x39,0x00,0x18,0x58,0xC6,0x02,0x37,0x61,0x63,0xC4,0x03,0xE4,0x20,0x04,0x0F,
0x59,0x92,0x25,0xB6,0x90,0xB0,0xF6,0x0D,0xDF,0x98,0x7D,0xFC,0x5D,0xDC,0x9E,0xE4,
0xAE,0x07,0xF0,0x5C,0x81,0x1E,0xD4,0x16,0xBB,0x3D,0x2E,0xB8,0xF0,0x8F,0x49,0xC0,
0xEA,0xC3,0x5F,0x5C,0xFF,0xD3,0x38,0x16,0xDF,0x02,0x81,0x81,0x00,0xDB,0x9F,0xC8,
0xBD,0x89,0x59,0x46,0x28,0x4F,0xD2,0xB1,0xF4,0x48,0xB5,0xAC,0xAA,0x32,0xB8,0xD5,
0xE3,0x0A,0x45,0x5E,0x94,0x3D,0x70,0x3B,0xC2,0x91,0x3E,0xE1,0x5D,0x17,0x92,0x44,
0x32,0x47,0xDD,0x31,0xE7,0x04,0xB5,0x49,0x96,0x8F,0x18,0xE3,0x08,0x2B,0x56,0x82,
0x93,0xA8,0x68,0x03,0x9A,0x34,0xEF,0xFD,0x54,0x91,0x26,0xA4,0x1C,0x8A,0xC0,0x80,
0x6B,0x41,0xB3,0xC3,0x86,0xEE,0x04,0xA1,0x74,0xEB,0x13,0xDF,0xBE,0x58,0xEF,0x36,
0xF4,0xC5,0xCC,0x97,0x7F,0x61,0x5F,0xFB,0x01,0x28,0x4E,0xE8,0x0B,0x18,0x8B,0x5A,
0x2C,0xC5,0xD8,0xB0,0xDB,0xD6,0x81,0xF7,0xF1,0x82,0xFD,0xCD,0x07,0x14,0x51,0xAF,
0x1D,0x22,0x55,0x67,0xD6,0x34,0xDC,0x30,0x33,0x06,0x73,0x35,0x01,0x02,0x81,0x80,
0x70,0xEA,0x73,0x6E,0xCA,0x88,0xD8,0xDD,0xAA,0x22,0xD4,0x93,0xBB,0x8C,0xB9,0x0C,
0xED,0xCE,0xF2,0x1A,0xBE,0x43,0x18,0x78,0x66,0x0D,0x36,0xAB,0xEF,0xAB,0xA0,0xC5,
0xB8,0xAB,0x00,0x6B,0x82,0x36,0x55,0x18,0x45,0x5B,0x18,0xEE,0x20,0xD1,0x12,0x35,
0xEB,0x00,0x1D,0xC3,0xD5,0xBC,0xF5,0xE9,0x6F,0x6D,0xD4,0x48,0xFA,0xFA,0xA6,0x82,
0x0A,0x86,0xFA,0x63,0x24,0x11,0xD8,0x71,0x26,0x28,0x2B,0x57,0x9F,0xC7,0xD1,0x80,
0x99,0x04,0x2F,0x6F,0x35,0x14,0x80,0x80,0xDE,0x6B,0xA8,0x0F,0x1E,0x1A,0x23,0xC3,
0x2F,0x79,0x36,0x4F,0x45,0x8C,0xF9,0x1F,0x73,0x09,0xED,0xA3,0x88,0x1D,0x1F,0xD2,
0x5E,0x35,0x97,0x52,0x40,0x6D,0x7F,0xB1,0xC6,0x3D,0x35,0xF4,0x4C,0x0E,0x56,0x87,
0x02,0x81,0x80,0x56,0xEE,0x9F,0x51,0xCE,0xCD,0x04,0x85,0x2E,0x5B,0x72,0xCF,0x03,
0xFC,0xCD,0x74,0xAD,0x11,0x16,0xB0,0x80,0xBF,0x46,0x99,0x9C,0xDC,0x10,0xFB,0x89,
0xEC,0x7E,0xDE,0x0F,0x57,0x79,0x21,0x01,0xEB,0x1F,0x36,0x97,0x59,0x7E,0xE0,0x56,
0x91,0xFE,0x43,0x9C,0x8B,0xE8,0xB1,0xB3,0xC6,0x40,0x2E,0xC8,0xE7,0x79,0xBA,0x00,
0x9E,0x6F,0xF5,0x50,0x42,0xB4,0x52,0x40,0x36,0x7C,0x9D,0xAB,0x17,0x30,0x25,0x8C,
0x6B,0x58,0x74,0x0A,0xD5,0xDD,0x45,0xF4,0x09,0x70,0xAA,0x1E,0x0C,0x14,0xD9,0xB7,
0x6F,0xCC,0x4F,0xA0,0x0E,0x80,0xCA,0x1A,0x22,0x14,0x97,0x60,0x08,0x1F,0xF1,0x7B,
0xED,0x24,0x3B,0xBA,0x22,0x3F,0x13,0x64,0x24,0xB4,0x2E,0x48,0xCC,0x23,0x53,0xFF,
0x28,0x99,0x01,0x02,0x81,0x80,0x1C,0xE4,0x21,0x03,0xF9,0x42,0xC2,0x24,0x3D,0x61,
0x68,0x1D,0xA0,0x2F,0x9C,0x4F,0x16,0x61,0x79,0x72,0xD9,0x7C,0xB8,0x80,0xF6,0xDE,
0x2B,0xBD,0xF4,0xE2,0xA6,0x35,0xC3,0x94,0xF5,0x86,0xEA,0xA4,0xA3,0x76,0xDB,0x0D,
0xCC,0x7C,0xF2,0x97,0x98,0xB0,0x79,0x92,0xEC,0x0E,0x43,0xF6,0x5C,0x30,0x2E,0xC5,
0x80,0xCF,0x46,0x4C,0x66,0x59,0xAA,0xB6,0x7D,0xD5,0xFA,0x63,0x07,0x0A,0x7E,0x71,
0x17,0x68,0x9E,0x5A,0x59,0xC8,0xDB,0xFC,0x35,0x7C,0xB1,0xD6,0xCD,0xC5,0x09,0x3F,
0x68,0x70,0xFF,0xA5,0x7C,0x35,0x3B,0x1B,0xD9,0x46,0x18,0xA0,0x66,0x86,0xCA,0x44,
0x84,0xC4,0x2C,0x23,0x3C,0x07,0x5D,0xEE,0x8A,0xD5,0x01,0x87,0x35,0x97,0x63,0xAD,
0x3E,0x0B,0x8F,0xB5,0x13,0xE3,
    }
};


cryptoST_testData_t sig2048 = {
    .length = 256,
    .data = (DATA_CHAR[256]){
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    }
};

const cryptoST_testData_t der4096 = {
    .length = 2350,
    .data = (DATA_CHAR[2350]){
0x30,0x82,0x09,0x2A,0x02,0x01,0x00,0x02,0x82,0x02,0x01,0x00,0xCD,0xF7,0x9B,0x32,
0xD9,0x77,0xC4,0xFB,0xDB,0x3E,0x0D,0x45,0xE4,0x81,0x4E,0x71,0x5D,0xB8,0x74,0xD3,
0x28,0x2C,0xD9,0xCD,0x15,0xDA,0xC3,0xFC,0xB2,0xB9,0xCF,0xCB,0x7C,0xC2,0xC1,0xFC,
0xA4,0x70,0x6D,0x58,0x81,0x87,0x0F,0xD0,0xCE,0x53,0x44,0xA0,0xF6,0x39,0x85,0x49,
0x66,0x8D,0xCC,0x4E,0x0A,0xF3,0xD2,0xD1,0xCF,0x69,0xB1,0xAE,0x35,0x44,0x9C,0x44,
0xB1,0x71,0xF6,0x56,0x4E,0x03,0x3D,0x14,0x0A,0xCD,0x7A,0x2A,0xD4,0x71,0xD6,0x9B,
0x56,0xD6,0xBE,0x78,0x2C,0x3E,0xA5,0x34,0xEE,0x98,0x57,0x5A,0x05,0x16,0x82,0x77,
0x5A,0x9B,0xF4,0xE8,0xE7,0x23,0xAA,0x0F,0xC8,0x9A,0xF1,0x25,0x37,0x82,0xE4,0x90,
0xD4,0x93,0x86,0xA4,0x12,0xED,0x10,0xC7,0x12,0x73,0xED,0xF2,0xAF,0xEC,0x35,0x1C,
0x5A,0xA1,0x3F,0x9D,0xA1,0xA5,0xA2,0xA7,0xF1,0xB1,0xA5,0x0E,0x74,0xAE,0xE9,0xA4,
0xAA,0xB7,0xE3,0x97,0xA7,0x0A,0xC9,0xA1,0x9A,0x80,0xED,0x9F,0xDA,0xA4,0xDE,0x1B,
0x6F,0x33,0xED,0xC1,0xAC,0x74,0xFB,0x81,0x19,0xA6,0xEF,0x31,0x0F,0x9F,0x7F,0x13,
0x19,0xA1,0x1D,0x3C,0xD5,0x04,0xF1,0x6E,0x66,0x10,0xCC,0x5F,0x9D,0x23,0x34,0x55,
0x28,0x33,0x38,0x54,0xC9,0xD6,0x82,0xEC,0x50,0x5F,0xE2,0x53,0x25,0x4A,0xCC,0x63,
0x23,0x99,0x68,0x52,0x4A,0x35,0x3F,0x6C,0x73,0x09,0x44,0x52,0x48,0x05,0x4D,0x0E,
0x91,0x49,0xCF,0xBA,0x16,0x6C,0x8F,0x55,0x30,0x4B,0xD8,0xCD,0x02,0xBB,0x8E,0xCC,
0xA1,0x7A,0x24,0xAB,0x47,0x8C,0x5A,0x92,0x0D,0x1D,0x4A,0x1A,0xA8,0xE3,0x03,0x34,
0xE1,0x19,0x4F,0xE8,0x8B,0xBF,0x90,0x58,0xCD,0x5F,0x3A,0x83,0xA3,0xC0,0x81,0x66,
0x12,0xD9,0xE8,0x8A,0xAB,0xDF,0x56,0x6C,0x50,0x1C,0x0B,0xD1,0xAB,0xAD,0x93,0x3B,
0xBA,0x91,0x23,0xA0,0xA9,0x76,0x92,0xDC,0xA7,0x48,0xDA,0x16,0xDA,0x09,0x07,0x73,
0x52,0xD9,0x1E,0x8B,0x46,0x58,0xA0,0xE3,0xBF,0xC3,0xE6,0x31,0x61,0x8A,0xFD,0xF1,
0x1C,0xF2,0x47,0x96,0xAB,0x93,0xEB,0x1E,0x90,0xDA,0x04,0x67,0x72,0x6C,0xC1,0x42,
0x8B,0xD9,0xFA,0xC9,0xAA,0x7F,0x2C,0xAE,0x0A,0x59,0xC4,0x01,0xCA,0x1F,0x61,0x48,
0x24,0x80,0x67,0xDE,0xFF,0x54,0x17,0x9A,0xCA,0x4B,0x3A,0x0A,0x5A,0x01,0xD9,0xD1,
0xC2,0x5D,0x88,0xD8,0x78,0xA6,0x9B,0x3C,0xAC,0xD1,0xBC,0xC6,0xEA,0x71,0x49,0x19,
0x40,0x3D,0x36,0x5E,0x8E,0x2B,0xA5,0x54,0xA4,0x82,0x5C,0x1E,0x02,0x61,0x72,0x90,
0x15,0xBB,0x5E,0xB7,0x63,0xBF,0x2E,0x67,0x94,0x90,0xC2,0x27,0x66,0xBB,0x79,0xFD,
0x69,0x40,0xB8,0x0A,0x48,0xA5,0xF7,0x36,0x33,0xF5,0x3F,0x56,0x57,0xD3,0xB4,0x47,
0xA3,0xA4,0x08,0x9E,0xFA,0xCC,0x54,0x43,0x84,0x59,0x5E,0x2E,0x2F,0xC8,0x6A,0x09,
0xCC,0x20,0x81,0xBA,0xE4,0xBC,0xE1,0xF5,0xCC,0x2D,0x3A,0x22,0x14,0x77,0xF6,0xCF,
0xA9,0x16,0xAF,0xAE,0xDF,0x7C,0xFE,0x4E,0x58,0x12,0x51,0x35,0xA4,0xC4,0xE8,0x3B,
0x8A,0xE9,0x02,0x0E,0x6A,0xEC,0x97,0x17,0x00,0x47,0x6A,0x05,0x9F,0x24,0x60,0x2F,
0xC0,0x0A,0x6E,0x13,0x13,0x85,0xDC,0x24,0xC6,0x45,0x0A,0x81,0x02,0x03,0x01,0x00,
0x01,0x02,0x82,0x02,0x00,0x33,0x32,0xE0,0xA6,0x74,0x3E,0x7C,0x7D,0xEA,0xD2,0xF2,
0xF3,0xB3,0xC8,0x9C,0xDA,0x3B,0x64,0xD5,0xCD,0x83,0x88,0x1A,0xA0,0x0B,0x55,0xB5,
0x30,0x44,0xB1,0x41,0xC1,0x20,0x83,0x3D,0x3B,0x73,0x18,0xEB,0x65,0x7B,0xD5,0x3A,
0x0E,0x3A,0xAB,0xA2,0x3C,0xAC,0xD8,0x41,0x94,0xAC,0x64,0x85,0x2B,0xC5,0x37,0x34,
0xE9,0xA8,0xB8,0x6A,0x4D,0x96,0xBA,0x36,0x6A,0x30,0xFD,0xD6,0x31,0x3F,0xF5,0x38,
0x22,0x9A,0x48,0xD7,0x9C,0x7B,0xF0,0xCC,0x5B,0x12,0xEC,0x10,0xAE,0xC8,0xB8,0xCD,
0xD2,0x69,0x98,0xFE,0xE5,0xC6,0xAC,0x00,0xC4,0x70,0x86,0xA2,0x0B,0x9F,0x21,0x53,
0x6D,0xD6,0xFD,0x05,0x02,0xAE,0x58,0xE0,0x3E,0x4C,0x49,0x5B,0xC7,0xBF,0x58,0xA4,
0xBA,0x07,0x91,0x3F,0xCD,0xFB,0x03,0x29,0x74,0xA1,0xE6,0xC1,0x6C,0x8A,0xB9,0x24,
0xC4,0xC0,0xA4,0xDB,0x15,0xCB,0xD5,0x8B,0x08,0xBE,0xD3,0x35,0x45,0x06,0x65,0xFD,
0x17,0x29,0xD3,0xF0,0xBD,0xB2,0xD9,0x16,0xC9,0x15,0x0C,0x80,0x86,0x8B,0x3B,0x0D,
0x25,0xDB,0x5D,0x8E,0xC9,0xD0,0x4B,0x62,0x88,0x39,0xEF,0xBD,0xD7,0xD8,0x50,0x01,
0x3F,0xE3,0x29,0x3B,0xD4,0x6C,0xB8,0x4A,0x92,0xFC,0x8A,0x36,0xEF,0x84,0xB8,0xC9,
0x14,0xBB,0x2A,0x0A,0x95,0x86,0x88,0xA0,0x63,0xE8,0x7E,0x82,0xDB,0x29,0xCD,0x30,
0xB5,0xE1,0xA6,0xA5,0x10,0x1B,0x0D,0x0E,0x49,0x97,0xBE,0x14,0x5F,0xFA,0xA1,0x03,
0xC4,0x36,0x5C,0x34,0x49,0x49,0xEB,0x9B,0xA4,0xAC,0x63,0x33,0x68,0x4C,0x41,0xCC,
0x65,0xCF,0xD2,0xBF,0x0F,0x8D,0x09,0x38,0x88,0xE7,0x5B,0x35,0x08,0x37,0xA5,0x47,
0x1C,0x68,0xD3,0x7A,0xA5,0xDE,0xC5,0xB3,0x5F,0x1A,0x8A,0xAC,0xEA,0x82,0xF2,0x5D,
0x8E,0x43,0xFD,0x2C,0x65,0x3D,0xFC,0x2E,0x9A,0x97,0x45,0xAB,0x54,0x29,0x63,0xEE,
0x7B,0x7D,0xA5,0x1D,0x00,0x9B,0x17,0xC5,0x92,0x2F,0x06,0x66,0xAF,0x9C,0xF0,0x11,
0x68,0xD8,0x71,0xC1,0x48,0xD5,0x5C,0xF6,0xE8,0x39,0x2F,0x9A,0xC1,0x50,0x9A,0xB6,
0x1B,0x0C,0x37,0xFE,0xD9,0x22,0xF3,0x4E,0xB5,0x66,0xE8,0xA7,0xF8,0xF9,0xAD,0x0A,
0xF9,0x6C,0x55,0x17,0x6D,0xA2,0xD3,0x1E,0x61,0x82,0x4E,0x3D,0x1B,0xC2,0x2F,0x84,
0x02,0xE0,0xFF,0xE6,0xC7,0x59,0xC4,0xD2,0x7A,0x77,0xBC,0x43,0x78,0x70,0xE3,0xBE,
0x71,0x15,0x69,0xB8,0xBE,0x0A,0xC7,0xAA,0x7C,0x30,0x2D,0x35,0x51,0x03,0x7F,0x77,
0x38,0x12,0x8E,0xE0,0xE9,0x60,0x3F,0x10,0x17,0x7D,0x42,0xEB,0x68,0x1B,0xA5,0x7A,
0x58,0x72,0xA8,0xBD,0xCC,0xC2,0xB8,0xC4,0x43,0x49,0x94,0x80,0xBD,0xDF,0xAB,0x8D,
0xE2,0xE1,0x73,0x0A,0xB9,0xE9,0x62,0x7A,0xDD,0xC0,0xA3,0xDF,0x02,0xDF,0x35,0x2C,
0xBC,0xBE,0xC9,0x9A,0x83,0xA2,0xE0,0x9B,0x1F,0x4F,0x25,0x49,0x85,0x71,0x7E,0xAB,
0xCB,0xC4,0x64,0x02,0x36,0x39,0xC7,0x63,0x4B,0x6B,0x3D,0xE4,0x2A,0x58,0xFA,0x57,
0xC5,0xA6,0x57,0x96,0xBF,0xFB,0xE2,0xE1,0xCF,0x25,0xCF,0x99,0xB6,0x04,0x2D,0xFF,
0x0B,0xDC,0xF1,0x6A,0xEB,0x86,0x30,0x1D,0xE1,0x3A,0xD4,0x54,0xF2,0x58,0x00,0x5F,
0xE7,0xBB,0xF8,0x82,0x4D,0x02,0x82,0x01,0x01,0x00,0xF6,0x41,0x7A,0xF6,0x09,0x60,
0x3C,0x73,0x32,0xAA,0x2A,0x04,0xC8,0xAE,0x3B,0xFF,0x4A,0x0C,0x22,0xA6,0x49,0xF4,
0x19,0x87,0x00,0xC3,0xA9,0xC5,0xF9,0xC0,0xFD,0x3A,0x40,0xD9,0xEF,0xDE,0x3A,0x20,
0x5A,0xD1,0xB7,0xBF,0x41,0x85,0xEE,0x7C,0x4D,0xD7,0x50,0xFC,0xC1,0xF0,0x6F,0xAE,
0x04,0x61,0xCE,0xA1,0x70,0x96,0xB2,0x9D,0xC5,0xB3,0x91,0x8D,0x7D,0x29,0x1F,0x0D,
0xF4,0xC4,0x5D,0x87,0x0C,0x7F,0xB1,0x64,0xF3,0xA5,0xB4,0xBD,0x70,0x6D,0x0A,0x1E,
0xE1,0x91,0xDB,0xC6,0xB9,0x70,0x19,0xFE,0x86,0x50,0x18,0xAD,0xAE,0x6B,0x65,0xC0,
0x6B,0x45,0x45,0xF8,0xB3,0x74,0x7E,0x89,0x23,0xA3,0x8C,0xE6,0x14,0x7F,0xB6,0x0D,
0xB9,0xED,0x1A,0x2A,0x67,0x7E,0x14,0xB3,0x90,0xE8,0x9A,0x20,0xA1,0xD1,0x0D,0x1B,
0x2B,0xBB,0x9B,0x1C,0xF3,0xE3,0xD6,0x81,0xD1,0x08,0x61,0x03,0x06,0x65,0x54,0x27,
0x81,0x9E,0x98,0xF4,0xC8,0x01,0x45,0x13,0x3A,0x2D,0x57,0x54,0xC1,0x36,0x66,0x60,
0xB0,0x92,0x54,0x6B,0x56,0x7B,0x0F,0x14,0xE8,0xB0,0x34,0xAF,0x8E,0xF6,0x56,0x30,
0x58,0x56,0x81,0xCA,0x70,0xC4,0x12,0xD8,0x32,0x31,0xCF,0x39,0x4D,0x72,0x03,0x76,
0x91,0x40,0xA9,0x7C,0xD0,0x16,0xAB,0x6C,0xAD,0x02,0x6C,0xAC,0x69,0x3F,0xE4,0x24,
0x1D,0xAB,0x1D,0x88,0x8C,0xA1,0x26,0x0A,0x51,0x72,0x7C,0xBB,0x74,0x08,0x2C,0x4E,
0x56,0xBA,0x64,0xCD,0x3D,0x2F,0xEC,0xE2,0x77,0xC8,0x7A,0x23,0x7F,0xA9,0xCA,0x9D,
0xBE,0xDA,0x1A,0x45,0x73,0xED,0x6A,0x49,0xE5,0x17,0x02,0x82,0x01,0x01,0x00,0xD6,
0x1E,0x02,0xD8,0x7F,0x70,0x58,0x37,0x90,0x98,0x15,0x33,0x61,0x84,0x53,0xB6,0xC1,
0x44,0x93,0xB9,0x8C,0x2E,0x76,0xC2,0xAD,0x37,0x3A,0xAE,0x33,0x9A,0xCD,0xAF,0x70,
0x35,0xC3,0x99,0x3F,0xC1,0xC0,0x0E,0xE7,0xC8,0x82,0xD4,0xF3,0xB7,0xBF,0x6F,0x09,
0xB1,0xB3,0x3E,0x85,0x70,0x90,0x41,0x03,0x6F,0x7E,0xBB,0x5E,0x09,0x43,0xA2,0x86,
0xBF,0xE2,0x28,0xBE,0x1C,0x54,0x70,0xFB,0x30,0x5B,0x59,0x14,0xBE,0x52,0xF1,0x63,
0xBA,0xD2,0xEB,0xB3,0x83,0x34,0x78,0xE2,0xB1,0x66,0x65,0x68,0x7B,0xBD,0xE1,0x0D,
0x40,0x15,0xF2,0x37,0x34,0x07,0x91,0xAC,0x7B,0x96,0x25,0x5E,0x5E,0x01,0xDB,0xF1,
0x23,0x6F,0x78,0x22,0xCD,0x90,0xD6,0x56,0x7B,0xD5,0xE2,0xE5,0x73,0x52,0xFC,0x19,
0x82,0x2E,0x30,0xD2,0x84,0x0F,0x18,0x8A,0xAD,0x18,0xC0,0xC7,0x1A,0xB7,0x3C,0xC5,
0x9D,0x56,0x3C,0xAE,0x36,0x16,0x27,0x98,0x16,0x60,0xD6,0x86,0x88,0xC2,0x75,0x08,
0x01,0xDE,0x49,0x4C,0xD4,0x55,0x2F,0x61,0x1F,0x26,0x93,0xE6,0x82,0x04,0xE3,0x83,
0xE3,0x29,0xE3,0x03,0x29,0x3D,0x7E,0xB2,0xED,0xDE,0xA0,0xAF,0xB6,0x2B,0xCB,0x23,
0x71,0x55,0x52,0x8E,0xFF,0xC2,0x84,0x86,0x24,0x70,0x8E,0xF7,0x85,0x88,0xF4,0xA9,
0x5B,0x5E,0x3F,0xCA,0x95,0x85,0x2C,0x24,0x10,0x3F,0x13,0xB2,0x85,0xC2,0x23,0x51,
0x39,0xD7,0xBB,0xE2,0x7F,0x55,0x84,0xDD,0x88,0x51,0x87,0x78,0x82,0xC2,0x1B,0x6F,
0x96,0xB1,0xF4,0xE7,0xCE,0xA6,0x79,0x8F,0x4F,0x96,0xA6,0x65,0xD4,0x7C,0x27,0x02,
0x82,0x01,0x01,0x00,0xE5,0x69,0x2F,0x22,0x12,0xAE,0x02,0xE2,0xD6,0xEA,0x4B,0xE6,
0xD5,0x05,0xEC,0x82,0xF1,0xFA,0xC8,0x34,0xDE,0x64,0x77,0x7B,0x9B,0xAC,0xAC,0x76,
0xF1,0x2B,0x67,0x3D,0x63,0xB9,0x24,0x8B,0x84,0xDF,0x2B,0x7C,0x80,0x8F,0xBE,0x7D,
0x05,0x25,0xEC,0x66,0x90,0xDE,0x47,0xD6,0xB4,0x54,0x0B,0x65,0x0A,0xD8,0xBF,0x48,
0xC4,0xF1,0xD2,0x82,0x6D,0x30,0xC0,0xCF,0x14,0x4D,0x2E,0x1F,0xD9,0x79,0xBC,0x9D,
0x21,0x28,0x09,0x0B,0xF0,0x8B,0x23,0x37,0x91,0xDC,0x1F,0x0C,0x81,0x10,0x6B,0x25,
0x12,0x32,0x59,0xF2,0x38,0x6B,0x65,0x38,0x4C,0x3C,0xAC,0x32,0x86,0xF3,0x20,0x4B,
0x80,0xAE,0x45,0xF3,0x51,0x89,0xEE,0xC2,0xE3,0x59,0x7A,0x42,0x76,0xC3,0xD6,0x52,
0x50,0xFA,0xD0,0x1E,0xC1,0xA7,0x70,0xD8,0x8E,0x3B,0x27,0xCC,0xC8,0xBE,0x7A,0x3F,
0x61,0x50,0xE2,0xE9,0xC9,0x66,0xC6,0x08,0x94,0x13,0x91,0xDF,0xAC,0x63,0x2E,0x08,
0x70,0xCF,0x6E,0xBD,0x5A,0xC4,0x6C,0x93,0x3F,0x61,0x08,0x5D,0xEA,0x23,0x6D,0x17,
0x8B,0x7F,0x51,0x1F,0x06,0x96,0x1E,0xBB,0x42,0xA4,0x1B,0x47,0xCB,0xF6,0x4A,0x83,
0x7F,0x82,0xC5,0x90,0x3D,0x9B,0x06,0x99,0x16,0xBC,0xD8,0xA8,0xC2,0xBC,0xB2,0x26,
0xCC,0x60,0x9B,0xF4,0xCC,0x44,0xFA,0x70,0x39,0x1B,0xA4,0x40,0x0B,0x6D,0x70,0x85,
0x98,0x28,0xB8,0xA3,0xCD,0xAB,0xDC,0x76,0xD8,0xBF,0xCA,0x70,0x2F,0x04,0x3C,0xE2,
0x6E,0xEE,0xB3,0xE4,0xA2,0x54,0x7B,0xD4,0x34,0x1C,0x2C,0xF6,0x86,0xCE,0xF9,0x26,
0xCE,0x84,0x34,0xD5,0x02,0x82,0x01,0x01,0x00,0xB1,0x5A,0x32,0x69,0x39,0x45,0xC9,
0x0C,0x5D,0x4C,0x5B,0x63,0x2F,0xC6,0xF7,0xC0,0x4C,0xDD,0x8C,0xAF,0x08,0x1A,0x04,
0x6C,0xC4,0x25,0x17,0x09,0xEB,0xDC,0xB1,0xBA,0x3B,0x6B,0x8D,0x14,0x86,0xE6,0xE9,
0x3A,0x6F,0x6A,0x7A,0x54,0x01,0x7B,0x95,0xA9,0x57,0x92,0x45,0x31,0xE8,0x3D,0x90,
0x7F,0x09,0x65,0x74,0xC7,0xA5,0xE0,0x6E,0x91,0x54,0xA3,0xE3,0xA4,0x73,0xB3,0xEB,
0x8D,0x99,0xC2,0x38,0x27,0xD5,0x32,0xC0,0x69,0x09,0x7E,0x59,0xEE,0xB9,0xC6,0x57,
0xD4,0x39,0x91,0x4F,0x8B,0x77,0xBB,0xE7,0x4F,0x5E,0x36,0x52,0xF7,0x4A,0x1A,0x62,
0x9A,0x9B,0x0F,0xD3,0x12,0x28,0xD4,0x1D,0x1E,0x1C,0xE2,0x89,0x16,0x2D,0x5D,0xB0,
0x36,0x99,0x74,0x01,0x79,0xEB,0x2C,0x56,0xF4,0x51,0xFC,0xAE,0x5D,0xEA,0x41,0x50,
0x6F,0xB7,0x8E,0x21,0x0E,0xAC,0xDC,0xC8,0x22,0x22,0x5D,0x6C,0x6C,0xDE,0xB0,0x16,
0x31,0xBD,0x9B,0xEB,0xA2,0x45,0xD5,0x49,0x9C,0xBE,0x81,0x2D,0xA9,0xF1,0x65,0x7F,
0x19,0xBB,0x8C,0x9D,0xDB,0xAB,0xF6,0xCE,0x2D,0xD5,0xB4,0x77,0xA1,0x7D,0xA0,0xCF,
0x3A,0xFE,0xE2,0x60,0xA1,0x20,0x69,0xF8,0x64,0x4E,0x7B,0x35,0x7D,0x28,0xCD,0x58,
0x45,0x85,0x06,0xF1,0xE4,0xB9,0xC9,0x75,0xE3,0x91,0xD4,0x08,0x81,0x36,0x40,0x1B,
0x0A,0xB0,0xE4,0x74,0x1A,0xD0,0xA8,0x52,0x62,0x06,0x89,0xAE,0xD4,0x05,0x8C,0x0B,
0x3D,0xFE,0x71,0x47,0x76,0xBA,0xAF,0x34,0x30,0x9D,0x81,0x68,0xED,0xBE,0x84,0x41,
0x08,0x37,0x58,0x69,0x24,0x72,0xFC,0x49,0xC9,0x02,0x82,0x01,0x01,0x00,0xE5,0x25,
0xED,0xC4,0x48,0x1D,0x7E,0x5E,0x80,0xA1,0xCB,0xF4,0x93,0x4F,0x78,0x23,0x92,0xEC,
0x4B,0x62,0xA1,0xE9,0xDA,0xBC,0xEB,0x97,0xE7,0x21,0x90,0xDC,0xA5,0x13,0x9C,0xA7,
0xF0,0x74,0xE7,0xF6,0xD2,0x57,0xE7,0x0E,0x73,0xF8,0x11,0x3C,0x5F,0xB0,0x34,0xF5,
0x59,0x8A,0x36,0xD5,0x65,0xF1,0x5F,0xE4,0x1E,0x71,0x38,0x9F,0x5D,0x58,0x9F,0x54,
0x13,0x8C,0x1E,0x13,0xD9,0x61,0x91,0x84,0xDC,0x57,0xA6,0xD9,0x20,0xA6,0x4B,0x3F,
0xE4,0x8F,0x34,0x36,0x84,0x77,0xFF,0x07,0x91,0x5A,0xD8,0xDF,0x84,0x98,0x20,0xCB,
0x11,0x1E,0x2A,0xD2,0xEB,0xAD,0xC8,0x02,0x5F,0xF4,0xB6,0x79,0x37,0x3D,0x52,0x5B,
0xD6,0x46,0xC5,0x38,0x7A,0xEE,0x3C,0x76,0x51,0xC4,0x66,0x2B,0xD6,0x6B,0xB3,0x55,
0xB7,0x0F,0x41,0x7E,0xEB,0x07,0x32,0x8F,0xA2,0x0D,0xDD,0x10,0xD7,0x87,0xFB,0xCD,
0x0E,0x20,0xCA,0xCD,0xB2,0xFF,0xC0,0x94,0xBF,0xF6,0x2B,0x76,0xB8,0x71,0x2C,0xD8,
0x17,0x73,0x51,0x3F,0x72,0x55,0x36,0x15,0xD1,0xB5,0x90,0x7F,0xBC,0x07,0xB6,0xB4,
0x33,0xE7,0x2E,0x31,0x5D,0xD8,0x1E,0xE8,0xCF,0x3D,0xD4,0xF9,0x99,0xC0,0xCC,0x58,
0xAC,0x83,0x39,0xF3,0x2C,0x32,0x44,0xEF,0x35,0x8E,0x0E,0xB4,0xA3,0xB9,0xB6,0xB1,
0x45,0x7E,0xC9,0xC2,0xD8,0xE2,0xA0,0x39,0xE8,0xD4,0xE2,0xA8,0x6B,0xB6,0x10,0x2C,
0x43,0xDF,0x42,0x13,0xE4,0xA8,0xB3,0x07,0x7E,0x17,0xEB,0x22,0xAC,0xEA,0x1D,0x66,
0xF3,0xCB,0xFA,0x76,0xA0,0xA5,0xBF,0x79,0x2F,0xB8,0x52,0x61,0xBC,0xCC,
    }
};

cryptoST_testData_t sig4096 = {
    .length = 512,
    .data = (DATA_CHAR[512]){
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    }
};

const cryptoST_testData_t n1024 = {
    .length = 128,
    .data = (DATA_CHAR[128]){
0xec, 0x44, 0x4f, 0x7a, 0xbb, 0xae, 0xe3, 0x63, 0xa6, 0xd0, 0xab, 0xcd, 0xf8, 0xe5, 0xc7, 0x0b, 
0x17, 0xf0, 0xf7, 0x49, 0xb0, 0x9e, 0x18, 0xdc, 0xe4, 0x15, 0xe0, 0xf8, 0x51, 0x72, 0x55, 0xb9, 
0xfb, 0x12, 0x78, 0xaa, 0x3c, 0x4a, 0xbc, 0xe6, 0xaa, 0xde, 0xe0, 0x5e, 0xff, 0x35, 0x32, 0x45, 
0x0a, 0xb3, 0x1b, 0x54, 0x47, 0xe6, 0xaf, 0x71, 0x44, 0x07, 0x5d, 0x40, 0x2d, 0x00, 0x73, 0x3b, 
0x21, 0xf7, 0xca, 0xf2, 0xc7, 0xd6, 0xf9, 0xf5, 0xab, 0x05, 0xcb, 0x0b, 0x2f, 0x34, 0xca, 0x41, 
0x34, 0xa7, 0x7e, 0x16, 0xd3, 0x0c, 0x37, 0xbf, 0xf2, 0x6d, 0x26, 0xa7, 0xe2, 0xf0, 0x8e, 0x84, 
0xe5, 0xe5, 0x68, 0x9d, 0x69, 0x73, 0xfd, 0xd5, 0xdb, 0x31, 0x88, 0xe7, 0xf8, 0x2c, 0x98, 0xf2, 
0x09, 0x5e, 0x13, 0xaa, 0xfb, 0xa0, 0x78, 0x7b, 0x1d, 0xe9, 0xc2, 0x59, 0x20, 0x3f, 0x98, 0xd9
    }
};
const cryptoST_testData_t e1024 = {
    .length = 128,
    .data = (DATA_CHAR[128]){
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01
    }
};
const cryptoST_testData_t d1024 = {
    .length = 128,
    .data = (DATA_CHAR[128]){
0x36, 0xa5, 0x5e, 0x14, 0xaf, 0x10, 0x36, 0x3b, 0xb8, 0x3b, 0x8f, 0x61, 0x26, 0x6e, 0x4e, 0xe9, 
0x3b, 0xf2, 0x59, 0xdf, 0xcb, 0x5f, 0xe5, 0xb4, 0x41, 0x74, 0xe6, 0x01, 0xc9, 0x24, 0xbe, 0xbb, 
0x33, 0x5d, 0x04, 0x57, 0xab, 0x76, 0x45, 0xd6, 0xbc, 0x32, 0xac, 0x86, 0x8c, 0x54, 0x8b, 0x79, 
0xf8, 0x8d, 0x90, 0x86, 0x9f, 0xd2, 0xb5, 0x45, 0x67, 0x4c, 0xa4, 0xbe, 0xd1, 0x29, 0xc7, 0x7c, 
0xb6, 0x0c, 0x65, 0xd1, 0x34, 0x47, 0x4a, 0xaa, 0xd8, 0x56, 0x2d, 0xc6, 0x76, 0xcc, 0x8a, 0x03, 
0xce, 0xad, 0x1b, 0xbb, 0x67, 0x02, 0x34, 0xdc, 0x47, 0xd1, 0x65, 0x13, 0xc6, 0x9a, 0x79, 0x4e, 
0xf4, 0x22, 0xef, 0x51, 0x80, 0x38, 0xc4, 0xe2, 0x51, 0xb5, 0x0a, 0x61, 0xc3, 0x1e, 0xab, 0x52, 
0x35, 0x42, 0xaf, 0x04, 0x5f, 0xff, 0x87, 0xa8, 0xee, 0x23, 0x51, 0x69, 0x2c, 0x66, 0x41, 0xe1
    }
};

const cryptoST_testData_t c1024 = {
    .length = 128,
    .data = (DATA_CHAR[128]){
0x99, 0xa1, 0xbc, 0x3d, 0x95, 0xa4, 0x26, 0xb1, 0x46, 0x38, 0x71, 0x84, 0xf5, 0xfe, 0x40, 0x5c, 
0x85, 0x0c, 0x3f, 0xce, 0xf0, 0xd0, 0x78, 0x23, 0xc8, 0x83, 0x43, 0xc2, 0xb8, 0xd4, 0x39, 0x28, 
0x53, 0xc2, 0x5d, 0x86, 0x00, 0x2f, 0x6c, 0x1a, 0x4e, 0xa7, 0x2d, 0x95, 0x4c, 0x10, 0xd1, 0x77, 
0x5d, 0xca, 0xe2, 0xa2, 0x6e, 0x13, 0x2f, 0xce, 0x2f, 0xf5, 0xf2, 0xce, 0x01, 0xc1, 0x6c, 0x7b, 
0x36, 0xf3, 0xfe, 0x05, 0x7c, 0x21, 0x5e, 0x97, 0xf9, 0x50, 0xaa, 0xf1, 0xd3, 0x38, 0x21, 0xca, 
0xae, 0xa6, 0xc5, 0xfd, 0xef, 0x41, 0x6a, 0x59, 0x04, 0xf4, 0x7e, 0x8d, 0x11, 0x2d, 0xe9, 0x9c, 
0x17, 0x34, 0xb3, 0xf8, 0x6b, 0x04, 0x69, 0x0e, 0xd4, 0x38, 0x8a, 0xde, 0xd3, 0xca, 0xf3, 0xaa, 
0x1e, 0x93, 0xab, 0x3e, 0x2c, 0x57, 0x6e, 0x01, 0x48, 0x00, 0x94, 0xa0, 0x3e, 0xd5, 0x86, 0x89
    }
};
////////////////////////////////////////////////////////////////////////////////////////////

const cryptoST_testData_t n4096 = {
    .length = 512,
    .data = (DATA_CHAR[512]){
0xc7, 0x32, 0x4c, 0xf7, 0x27, 0xe0, 0x2b, 0xa4, 0xa3, 0x04, 0x3b, 0xf0, 0xd0, 0x01, 0xd8, 0x8f, 
0x80, 0xcc, 0x6e, 0xca, 0x58, 0x81, 0x24, 0x3b, 0x1c, 0xac, 0x85, 0xce, 0x00, 0xa9, 0xfc, 0xa1, 
0x5c, 0xf9, 0xa4, 0x2c, 0xa1, 0x3f, 0x87, 0x65, 0xe7, 0x8f, 0x82, 0xe4, 0x54, 0xb1, 0x50, 0x91, 
0xb2, 0x84, 0x34, 0x8b, 0x5e, 0xf7, 0x3d, 0x2d, 0xea, 0x55, 0xd7, 0x23, 0x03, 0x6c, 0xdf, 0x26, 
0xda, 0x3b, 0x39, 0x5c, 0x08, 0x18, 0x6d, 0xc7, 0xa0, 0x00, 0x23, 0x43, 0x2f, 0x64, 0xab, 0xb9, 
0xe4, 0x7a, 0x7e, 0x16, 0x09, 0x67, 0x0a, 0xaa, 0xa2, 0xfb, 0x40, 0x03, 0x31, 0xfd, 0xb9, 0xbc, 
0x50, 0x7e, 0x67, 0x7b, 0x43, 0xc0, 0xb9, 0x34, 0x52, 0xb2, 0x9c, 0xca, 0xa9, 0xa3, 0xed, 0x12, 
0x88, 0xd9, 0xf7, 0xf6, 0x4c, 0xc2, 0x54, 0xa6, 0xab, 0x51, 0x1e, 0x83, 0xad, 0x37, 0x7c, 0xd7, 
0x45, 0x37, 0x9a, 0xf9, 0x5d, 0x54, 0xa6, 0x78, 0x34, 0xaa, 0xe8, 0x11, 0xad, 0x12, 0xca, 0xe3, 
0x22, 0x42, 0xda, 0x97, 0x23, 0xe7, 0x17, 0xbd, 0x9e, 0x10, 0x69, 0x96, 0xb6, 0xf7, 0xbd, 0x7b, 
0x98, 0xc4, 0xb8, 0x41, 0x11, 0xb5, 0x33, 0xd7, 0x76, 0xdd, 0xe3, 0x2a, 0xc0, 0x46, 0xd1, 0x15, 
0x4b, 0x06, 0x59, 0x69, 0x93, 0xac, 0x2d, 0x42, 0xc0, 0xd4, 0x5d, 0xd9, 0x3a, 0xdb, 0x12, 0x17, 
0x31, 0x03, 0xe1, 0x66, 0xa2, 0x48, 0x67, 0x90, 0x6c, 0x8d, 0x29, 0xdd, 0xfe, 0xe4, 0x6d, 0xb1, 
0x6b, 0x20, 0x9d, 0xb1, 0x37, 0x47, 0x4a, 0x93, 0x93, 0x90, 0xcc, 0x93, 0x4b, 0xf2, 0x9c, 0xa2, 
0x84, 0x4a, 0x35, 0x95, 0x9b, 0xe9, 0x46, 0x06, 0x37, 0x38, 0x12, 0xd3, 0x29, 0xa0, 0xf3, 0x89, 
0xc8, 0x9b, 0xa7, 0x62, 0x39, 0x3f, 0xcf, 0x0c, 0x7b, 0x06, 0x76, 0x9b, 0xdc, 0x86, 0x84, 0x87, 
0xd9, 0xeb, 0x12, 0xb8, 0xd7, 0xe2, 0x7a, 0xa4, 0x02, 0xc4, 0x0f, 0xfa, 0x1e, 0xea, 0xbc, 0xa2, 
0x7f, 0x0b, 0x12, 0xc4, 0xf3, 0x3f, 0xf0, 0x98, 0x94, 0x25, 0x49, 0x95, 0xe2, 0x48, 0xd3, 0xa5, 
0xaf, 0xf2, 0x74, 0x49, 0x52, 0xe3, 0x81, 0xfc, 0x5b, 0x24, 0xa3, 0x38, 0x48, 0xc3, 0x45, 0x0a, 
0xdd, 0xf0, 0x5b, 0x41, 0x87, 0xe3, 0x30, 0x36, 0xd9, 0x54, 0x80, 0x0e, 0xd5, 0x0f, 0x0e, 0x79, 
0x4a, 0x3f, 0x2b, 0x2e, 0x07, 0xc7, 0x83, 0x2d, 0xfc, 0xaa, 0x94, 0xc9, 0xcb, 0x31, 0xbc, 0x56, 
0xf3, 0xfd, 0xa1, 0xbd, 0x30, 0x56, 0x57, 0x92, 0x91, 0x1a, 0x42, 0x5b, 0x2e, 0x2f, 0x71, 0x75, 
0x79, 0xda, 0x34, 0xc2, 0x26, 0x0b, 0x50, 0xb9, 0xde, 0xfe, 0x93, 0x11, 0x4d, 0xdc, 0xf6, 0xfd, 
0xf8, 0xe8, 0x2d, 0x20, 0xe6, 0x9c, 0xb7, 0xac, 0x1c, 0xd3, 0x8a, 0xfa, 0x25, 0xb1, 0xf9, 0x80, 
0x48, 0x97, 0x72, 0xcc, 0x75, 0x44, 0x3f, 0xc5, 0x71, 0xe7, 0x76, 0x34, 0x11, 0x24, 0x9a, 0x1c, 
0xc9, 0x5e, 0x3a, 0xea, 0xd5, 0x2c, 0x08, 0xed, 0xeb, 0xec, 0x35, 0xd4, 0x4e, 0x6b, 0xf6, 0x68, 
0xfe, 0x07, 0xd3, 0xa3, 0xe2, 0xcc, 0x40, 0x12, 0x6d, 0xbc, 0x64, 0x27, 0xd7, 0xbb, 0x0b, 0x5e, 
0x22, 0x6f, 0xd0, 0x77, 0x1d, 0x38, 0x9b, 0x9f, 0x31, 0x01, 0xdb, 0xcd, 0xc7, 0x1b, 0xab, 0x65, 
0xdc, 0x0c, 0x28, 0xb5, 0xcf, 0x46, 0xb8, 0xaf, 0x1f, 0xcb, 0xd9, 0x7d, 0xbf, 0x29, 0x41, 0xae, 
0x04, 0x56, 0x41, 0x58, 0x62, 0x58, 0xa4, 0xbe, 0x46, 0xfa, 0xad, 0xe0, 0x15, 0xc7, 0xbf, 0x6f, 
0xd9, 0x95, 0x73, 0x87, 0xc4, 0x6a, 0x95, 0xe4, 0xf6, 0xb0, 0x47, 0x00, 0x58, 0x94, 0x18, 0x22, 
0xd5, 0xcb, 0x88, 0x14, 0x82, 0x88, 0xe4, 0x0d, 0x1f, 0x47, 0xcd, 0x9a, 0x6d, 0xc7, 0xb8, 0x1f
    }
};
const cryptoST_testData_t e4096 = {
    .length = 512,
    .data = (DATA_CHAR[512]){
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01
    }
};
const cryptoST_testData_t d4096 = {
    .length = 512,
    .data = (DATA_CHAR[512]){
0x6c, 0xe6, 0x86, 0x07, 0x55, 0x28, 0x8c, 0x13, 0x9c, 0xff, 0xb2, 0x99, 0x6b, 0xce, 0xa6, 0x8b, 
0x85, 0xb9, 0xbe, 0x14, 0x27, 0xa0, 0xaa, 0xa3, 0x1a, 0x81, 0x03, 0x41, 0xe5, 0x41, 0x09, 0x99, 
0x5a, 0x50, 0x2c, 0xbe, 0x2d, 0x85, 0xa2, 0xcb, 0x46, 0x76, 0x41, 0xf3, 0xfc, 0x8d, 0x57, 0xe3, 
0xdf, 0x79, 0xc1, 0x94, 0x34, 0x5d, 0xec, 0x77, 0x8e, 0xb6, 0x51, 0x40, 0x96, 0x1d, 0xce, 0x3d, 
0xda, 0x6f, 0x28, 0x63, 0xb5, 0x15, 0x4d, 0xe7, 0x26, 0x05, 0x0d, 0x42, 0x2c, 0xc5, 0xd7, 0xd0, 
0x70, 0x25, 0xbb, 0x8a, 0xe6, 0xa7, 0x0b, 0xc0, 0xd0, 0x0b, 0x96, 0x2a, 0x69, 0x09, 0x32, 0xa2, 
0xce, 0x4a, 0xdc, 0xde, 0x19, 0xe3, 0x62, 0x1d, 0x45, 0xdc, 0xda, 0x35, 0x3d, 0xdb, 0x1d, 0xbf, 
0xd5, 0x4b, 0x7c, 0xf1, 0x8d, 0x73, 0x6c, 0x7e, 0x16, 0x08, 0xea, 0x2a, 0xc8, 0xe7, 0x1d, 0xfc, 
0x3e, 0x9e, 0x30, 0xbe, 0x85, 0x94, 0xc2, 0xd1, 0xd2, 0xd1, 0x60, 0xc0, 0x51, 0x23, 0x86, 0x01, 
0xf8, 0xf8, 0x1d, 0xb3, 0x25, 0x70, 0xb0, 0x9c, 0xfc, 0xae, 0x32, 0x5b, 0xb0, 0x39, 0xee, 0xc0, 
0x84, 0x7b, 0x7f, 0xd4, 0x2b, 0x0f, 0x2a, 0x81, 0x70, 0x3d, 0xcc, 0x74, 0xd1, 0xdb, 0xa5, 0x71, 
0x03, 0xac, 0x3b, 0xf3, 0xa9, 0x45, 0x27, 0x15, 0x68, 0x80, 0x71, 0xb2, 0x52, 0x27, 0xf4, 0x52, 
0xf3, 0x7c, 0x10, 0x9d, 0x60, 0xb9, 0x3e, 0xcd, 0x49, 0x5b, 0x3f, 0x79, 0x5b, 0x61, 0x9c, 0xca, 
0xb3, 0x2b, 0x88, 0xaa, 0x9a, 0xf3, 0x01, 0xc5, 0x7e, 0x96, 0x5a, 0x11, 0x69, 0x23, 0x01, 0x19, 
0x24, 0x43, 0xc1, 0xd9, 0xc1, 0xfc, 0x1d, 0x49, 0x46, 0xa5, 0x04, 0x3d, 0xa7, 0x73, 0x93, 0xd1, 
0x4e, 0xf8, 0x31, 0xe1, 0x54, 0x35, 0x1b, 0x47, 0xd2, 0x76, 0x6d, 0x1f, 0xb6, 0xc7, 0x5f, 0xea, 
0x42, 0x7a, 0xe6, 0xee, 0x88, 0x22, 0x16, 0x34, 0x52, 0xf9, 0x29, 0x03, 0x47, 0xc5, 0x9b, 0x10, 
0xad, 0x53, 0xdb, 0x5c, 0xe1, 0x73, 0x7c, 0xf6, 0xa8, 0x1e, 0x53, 0xd5, 0x43, 0x7a, 0x06, 0xe2, 
0x41, 0x76, 0x19, 0x42, 0x0d, 0x7c, 0x42, 0x14, 0xb1, 0x87, 0xfb, 0xc4, 0xc7, 0x73, 0xf3, 0xca, 
0x7e, 0x98, 0x3f, 0x71, 0xac, 0xc7, 0xfa, 0x19, 0x1d, 0xe4, 0x7c, 0x52, 0xe0, 0x08, 0x3e, 0x82, 
0x86, 0x42, 0xeb, 0x26, 0xc1, 0x2c, 0xcc, 0xa5, 0xbe, 0x24, 0x17, 0xe2, 0x0b, 0x60, 0x38, 0x27, 
0xec, 0xcc, 0x92, 0xf5, 0x06, 0xc3, 0x16, 0x28, 0x0f, 0x86, 0xfd, 0x6d, 0x16, 0xae, 0x0b, 0x59, 
0x4d, 0x46, 0x55, 0x6f, 0xce, 0xc5, 0xd3, 0xba, 0xe6, 0xb0, 0xdb, 0xc2, 0x4a, 0xe1, 0xbd, 0x5c, 
0x40, 0x07, 0xe9, 0x03, 0x54, 0x35, 0x70, 0x3c, 0x98, 0x46, 0x60, 0x23, 0xba, 0xee, 0x79, 0xbc, 
0xe1, 0x7b, 0xfc, 0x21, 0x28, 0x83, 0x3b, 0x54, 0xc8, 0xd3, 0x3a, 0x72, 0xf7, 0xca, 0x6f, 0xba, 
0xf0, 0x52, 0x3a, 0x8d, 0x22, 0xa1, 0x94, 0x81, 0x44, 0xd4, 0xe9, 0x00, 0x89, 0xd6, 0xc9, 0x63, 
0xd2, 0x45, 0x4f, 0xc2, 0xb3, 0xe9, 0xc1, 0xf4, 0xe8, 0x18, 0x07, 0x59, 0x28, 0xf3, 0xd4, 0x68, 
0x02, 0xc1, 0x3c, 0x36, 0x84, 0x7f, 0x81, 0xb7, 0xaa, 0x1f, 0xce, 0x3c, 0x84, 0x12, 0x3c, 0x54, 
0xee, 0x02, 0x4f, 0x3f, 0xa7, 0xe6, 0x09, 0x6b, 0xb2, 0x40, 0xe7, 0xc2, 0xb1, 0x95, 0x64, 0x58, 
0xe3, 0x55, 0x45, 0xe6, 0xb1, 0x88, 0x35, 0x29, 0x7c, 0x25, 0xe6, 0x13, 0x74, 0x89, 0x0d, 0x10, 
0x35, 0x3b, 0x46, 0x1b, 0x5b, 0x69, 0x7d, 0x9a, 0x33, 0xf2, 0xbe, 0x43, 0xac, 0x69, 0xde, 0x4a, 
0xf2, 0xc6, 0xd4, 0x3d, 0x7c, 0x69, 0xc5, 0x26, 0x5d, 0x33, 0x2b, 0x11, 0xe4, 0x55, 0x2f, 0x89
    }
};

const cryptoST_testData_t c4096 = {
    .length = 512,
    .data = (DATA_CHAR[512]){
0xc0, 0xf2, 0x32, 0x49, 0xb2, 0xcd, 0xb4, 0x7d, 0xba, 0x9b, 0x1c, 0x6c, 0xc5, 0x47, 0x4c, 0x11, 
0x92, 0xa2, 0x5b, 0x18, 0xef, 0xa0, 0x18, 0x27, 0x05, 0x94, 0xeb, 0xac, 0xf2, 0x95, 0xe3, 0x2e, 
0xfe, 0xf7, 0x43, 0xec, 0x42, 0x0a, 0x78, 0xe1, 0x70, 0x3b, 0x3b, 0x8d, 0x4e, 0xbd, 0xe7, 0x2b, 
0x39, 0xbf, 0x63, 0x9e, 0xec, 0x98, 0x7a, 0x8d, 0xe0, 0xb2, 0xf9, 0x39, 0xc0, 0x06, 0xd2, 0x64, 
0x5e, 0x5b, 0xc3, 0x51, 0x05, 0xd4, 0x62, 0x51, 0x33, 0x28, 0x25, 0x56, 0x7a, 0xab, 0xb6, 0x71, 
0xd4, 0xbe, 0x16, 0x56, 0x0d, 0x8a, 0x0d, 0x2d, 0xf2, 0xc9, 0xdb, 0x27, 0x1a, 0x11, 0x83, 0x4f, 
0x95, 0xff, 0xa2, 0x9c, 0x86, 0xd2, 0x39, 0xae, 0x62, 0xa9, 0xe2, 0x0a, 0x2b, 0x84, 0x1d, 0x65, 
0x80, 0x72, 0x38, 0x82, 0x7b, 0x49, 0xc5, 0x53, 0x77, 0xdf, 0x79, 0x22, 0x14, 0xbf, 0xd7, 0xd9, 
0x43, 0x6a, 0x9c, 0x70, 0x76, 0x96, 0x91, 0x59, 0xf2, 0x9e, 0x77, 0xc6, 0xe2, 0x79, 0x00, 0xb5, 
0x41, 0xd9, 0x67, 0x05, 0xaf, 0xdc, 0x43, 0x9f, 0xea, 0xc6, 0x08, 0xe1, 0xde, 0x35, 0x03, 0x6e, 
0x1f, 0x72, 0x64, 0xef, 0xa6, 0xc1, 0x5d, 0x74, 0xc0, 0xf7, 0x57, 0x36, 0x63, 0xb1, 0x08, 0xd7, 
0x49, 0x29, 0x74, 0x09, 0xe6, 0x80, 0x69, 0x63, 0x14, 0x14, 0xb9, 0xae, 0x20, 0x26, 0x26, 0xed, 
0xa7, 0xee, 0xf4, 0x1b, 0x76, 0xb0, 0xaf, 0x48, 0x61, 0x4b, 0x1c, 0x12, 0xaa, 0x49, 0x8f, 0x71, 
0x8e, 0x97, 0x1d, 0x1d, 0xa9, 0x3e, 0x44, 0xf3, 0xbc, 0xa2, 0x6d, 0x61, 0x49, 0x2b, 0xbc, 0xd8, 
0x47, 0xc7, 0xb4, 0x27, 0x71, 0xaf, 0x59, 0x03, 0x81, 0x65, 0x0f, 0xcc, 0x27, 0x32, 0x9e, 0xdb, 
0xb9, 0xad, 0x0d, 0x43, 0x9c, 0x0a, 0x9c, 0xa2, 0x29, 0xd0, 0x36, 0x6a, 0x4d, 0xb3, 0x9b, 0xcd, 
0x08, 0xcc, 0xbb, 0x2b, 0x6f, 0x6e, 0x0c, 0x63, 0x1c, 0x9a, 0x00, 0xf2, 0xd5, 0x37, 0xc0, 0xd6, 
0xfe, 0xf5, 0x44, 0xd3, 0x8e, 0xea, 0xe7, 0xa9, 0x32, 0x60, 0xb4, 0xab, 0x5e, 0x84, 0x63, 0xe4, 
0x0a, 0x1d, 0xf9, 0x5d, 0x04, 0x3a, 0xe8, 0xd2, 0xae, 0xcb, 0x20, 0x05, 0xb1, 0x64, 0x08, 0x68, 
0xab, 0x8b, 0xbb, 0xc3, 0x6a, 0x97, 0x16, 0x55, 0x0d, 0x44, 0x22, 0x1c, 0x54, 0x70, 0xdd, 0x27, 
0x8f, 0xcc, 0xc4, 0xc9, 0x95, 0x1e, 0x99, 0x1c, 0xa2, 0xb4, 0x27, 0x78, 0xbc, 0x86, 0x6d, 0x8d, 
0x4a, 0xcc, 0x1b, 0xf6, 0xbf, 0x6b, 0xfe, 0xdb, 0x2b, 0x63, 0x39, 0x58, 0xc8, 0x08, 0xc2, 0xa5, 
0xe8, 0x38, 0x7a, 0x84, 0x47, 0x2c, 0x53, 0x63, 0x90, 0xb3, 0xf3, 0xc5, 0xbf, 0x43, 0x62, 0x9b, 
0x2b, 0x60, 0x22, 0x52, 0x41, 0xf4, 0xaa, 0x78, 0x21, 0x75, 0x4b, 0x44, 0x06, 0x8e, 0x82, 0x6e, 
0x50, 0x3c, 0xef, 0xb9, 0xb5, 0x59, 0x24, 0x0b, 0x72, 0xf4, 0x52, 0xf2, 0x87, 0xd2, 0xb9, 0xcc, 
0xec, 0xa4, 0x58, 0x13, 0xb4, 0xe7, 0x4d, 0x6b, 0xac, 0x25, 0xf9, 0x0b, 0x4c, 0xd1, 0x17, 0x20, 
0x48, 0x45, 0x9c, 0xd4, 0x74, 0x15, 0xab, 0x06, 0x69, 0xe3, 0x99, 0xb8, 0x31, 0xf0, 0x7d, 0xcb, 
0xa5, 0x67, 0x60, 0x60, 0x20, 0x24, 0x77, 0x08, 0x5e, 0x69, 0x16, 0x28, 0xf2, 0xa3, 0x8a, 0xde, 
0x80, 0x78, 0x62, 0x98, 0xf5, 0xe0, 0xab, 0x36, 0x80, 0xb3, 0xf4, 0x3c, 0x2b, 0x48, 0xf8, 0x84, 
0x57, 0x8f, 0x80, 0xd3, 0xbf, 0xb8, 0xb7, 0xec, 0x5c, 0x9f, 0xf7, 0xfc, 0x25, 0x66, 0x99, 0x57, 
0x6e, 0xaa, 0x8d, 0xf6, 0xac, 0x29, 0x44, 0x14, 0xa0, 0xc8, 0x7f, 0x6a, 0xe6, 0xa6, 0x38, 0x65, 
0xdf, 0xd9, 0x20, 0x30, 0x64, 0x9a, 0x95, 0xe2, 0x0d, 0x9a, 0x4a, 0x84, 0x8e, 0x87, 0x5d, 0xfe
    }
};
const cryptoST_testData_t e2048 = {
    .length = 256,
    .data = (DATA_CHAR[256]){
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01
    }
};
const cryptoST_testVector_t RSASP1_256_2048_7099enc =
{
    .name = "RSA2SP1_256_2048_7099enc",
    .source = __BASE_FILE__ "(" BASE_LINE ")",
    .description = "NIST suite RSA2SP1 (CAVS16p1) reversed for encryption",
    .vector.length = 256,
    .vector.data = (DATA_CHAR[256]){ // plaintext (golden data)
0x70, 0x99, 0x2c, 0x9d, 0x95, 0xa4, 0x90, 0x8d, 0x2a, 0x94, 0xb3, 0xab, 0x9f, 0xa1, 0xcd, 0x64, 
0x3f, 0x12, 0x0e, 0x32, 0x6f, 0x9d, 0x78, 0x08, 0xaf, 0x50, 0xca, 0xc4, 0x2c, 0x4b, 0x0b, 0x4e, 
0xeb, 0x7f, 0x0d, 0x4d, 0xf3, 0x03, 0xa5, 0x68, 0xfb, 0xfb, 0x82, 0xb0, 0xf5, 0x83, 0x00, 0xd2, 
0x53, 0x57, 0x64, 0x57, 0x21, 0xbb, 0x71, 0x86, 0x1c, 0xaf, 0x81, 0xb2, 0x7a, 0x56, 0x08, 0x2c, 
0x80, 0xa1, 0x46, 0x49, 0x9f, 0xb4, 0xea, 0xb5, 0xbd, 0xe4, 0x49, 0x3f, 0x5d, 0x00, 0xf1, 0xa4, 
0x37, 0xbb, 0xc3, 0x60, 0xdf, 0xcd, 0x80, 0x56, 0xfe, 0x6b, 0xe1, 0x0e, 0x60, 0x8a, 0xdb, 0x30, 
0xb6, 0xc2, 0xf7, 0x65, 0x24, 0x28, 0xb8, 0xd3, 0x2d, 0x36, 0x29, 0x45, 0x98, 0x2a, 0x46, 0x58, 
0x5d, 0x21, 0x02, 0xef, 0x79, 0x95, 0xa8, 0xba, 0x6e, 0x8a, 0xd8, 0xfd, 0x16, 0xbd, 0x7a, 0xe8, 
0xf5, 0x3c, 0x3d, 0x7f, 0xcf, 0xba, 0x29, 0x0b, 0x57, 0xce, 0x7f, 0x8f, 0x09, 0xc8, 0x28, 0xd6, 
0xf2, 0xd3, 0xce, 0x56, 0xf1, 0x31, 0xbd, 0x94, 0x61, 0xe5, 0x66, 0x7e, 0x5b, 0x73, 0xed, 0xac, 
0x77, 0xf5, 0x04, 0xda, 0xc4, 0xf2, 0x02, 0xa9, 0x57, 0x0e, 0xb4, 0x51, 0x5b, 0x2b, 0xf5, 0x16, 
0x40, 0x7d, 0xb8, 0x31, 0x51, 0x8d, 0xb8, 0xa2, 0x08, 0x3e, 0xc7, 0x01, 0xe8, 0xfd, 0x38, 0x7c, 
0x43, 0x0b, 0xb1, 0xa7, 0x2d, 0xec, 0xa5, 0xb4, 0x9d, 0x42, 0x9c, 0xf9, 0xde, 0xb0, 0x9c, 0xc4, 
0x51, 0x8d, 0xc5, 0xf5, 0x7c, 0x08, 0x9a, 0xa2, 0xd3, 0x42, 0x0e, 0x56, 0x7e, 0x73, 0x21, 0x02, 
0xc2, 0xc9, 0x2b, 0x88, 0xa0, 0x7c, 0x69, 0xd7, 0x09, 0x17, 0x14, 0x0a, 0xb3, 0x82, 0x3c, 0x63, 
0xf3, 0x12, 0xd3, 0xf1, 0x1f, 0xa8, 0x7b, 0xa2, 0x9d, 0xa3, 0xc7, 0x22, 0x4b, 0x4f, 0xb4, 0xbc
    }
};

const cryptoST_testVector_t OpenSSL_vector_1024 =
{
    .name = "OpenSSL_vector_1024",
    .source = __BASE_FILE__ "(" BASE_LINE ")",
    .description = "OpenSSL vector 1024",
    .vector.length = 128,
    .vector.data = (DATA_CHAR[128]){ // plaintext (golden data)
0x54, 0x68, 0x65, 0x20, 0x71, 0x75, 0x69, 0x63, 0x6b, 0x20, 0x62, 0x72, 0x6f, 0x77, 0x6e, 0x20, 
0x66, 0x6f, 0x78, 0x20, 0x6a, 0x75, 0x6d, 0x70, 0x65, 0x64, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x20,
0x74, 0x68, 0x65, 0x20, 0x6c, 0x61, 0x7a, 0x79, 0x20, 0x64, 0x6f, 0x67, 0x2e, 0x20, 0x54, 0x68,
0x65, 0x20, 0x71, 0x75, 0x69, 0x63, 0x6b, 0x20, 0x62, 0x72, 0x6f, 0x77, 0x6e, 0x20, 0x66, 0x6f, 
0x78, 0x20, 0x6a, 0x75, 0x6d, 0x70, 0x65, 0x64, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 
0x65, 0x20, 0x6c, 0x61, 0x7a, 0x79, 0x20, 0x64, 0x6f, 0x67, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 
0x71, 0x75, 0x69, 0x63, 0x6b, 0x20, 0x62, 0x72, 0x6f, 0x77, 0x6e, 0x20, 0x66, 0x6f, 0x78, 0x20, 
0x6a, 0x75, 0x6d, 0x70, 0x65, 0x64, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20
    }
};

const cryptoST_testVector_t OpenSSL_vector_1024enc =
{
    .name = "OpenSSL_vector_1024enc",
    .source = __BASE_FILE__ "(" BASE_LINE ")",
    .description = "OpenSSL vector 1024enc",
    .vector.length = 128,
    .vector.data = (DATA_CHAR[128]){ // plaintext (golden data)
0x99, 0xa1, 0xbc, 0x3d, 0x95, 0xa4, 0x26, 0xb1, 0x46, 0x38, 0x71, 0x84, 0xf5, 0xfe, 0x40, 0x5c, 
0x85, 0x0c, 0x3f, 0xce, 0xf0, 0xd0, 0x78, 0x23, 0xc8, 0x83, 0x43, 0xc2, 0xb8, 0xd4, 0x39, 0x28, 
0x53, 0xc2, 0x5d, 0x86, 0x00, 0x2f, 0x6c, 0x1a, 0x4e, 0xa7, 0x2d, 0x95, 0x4c, 0x10, 0xd1, 0x77, 
0x5d, 0xca, 0xe2, 0xa2, 0x6e, 0x13, 0x2f, 0xce, 0x2f, 0xf5, 0xf2, 0xce, 0x01, 0xc1, 0x6c, 0x7b, 
0x36, 0xf3, 0xfe, 0x05, 0x7c, 0x21, 0x5e, 0x97, 0xf9, 0x50, 0xaa, 0xf1, 0xd3, 0x38, 0x21, 0xca, 
0xae, 0xa6, 0xc5, 0xfd, 0xef, 0x41, 0x6a, 0x59, 0x04, 0xf4, 0x7e, 0x8d, 0x11, 0x2d, 0xe9, 0x9c, 
0x17, 0x34, 0xb3, 0xf8, 0x6b, 0x04, 0x69, 0x0e, 0xd4, 0x38, 0x8a, 0xde, 0xd3, 0xca, 0xf3, 0xaa, 
0x1e, 0x93, 0xab, 0x3e, 0x2c, 0x57, 0x6e, 0x01, 0x48, 0x00, 0x94, 0xa0, 0x3e, 0xd5, 0x86, 0x89
    }
};

const cryptoST_testVector_t OpenSSL_vector_4096 =
{
    .name = "OpenSSL_vector_4096",
    .source = __BASE_FILE__ "(" BASE_LINE ")",
    .description = "OpenSSL vector 4096",
    .vector.length = 512,
    .vector.data = (DATA_CHAR[512]){ // plaintext (golden data)
0x54, 0x68, 0x65, 0x20, 0x71, 0x75, 0x69, 0x63, 0x6b, 0x20, 0x62, 0x72, 0x6f, 0x77, 0x6e, 0x20, 
0x66, 0x6f, 0x78, 0x20, 0x6a, 0x75, 0x6d, 0x70, 0x65, 0x64, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x20, 
0x74, 0x68, 0x65, 0x20, 0x6c, 0x61, 0x7a, 0x79, 0x20, 0x64, 0x6f, 0x67, 0x2e, 0x20, 0x54, 0x68, 
0x65, 0x20, 0x71, 0x75, 0x69, 0x63, 0x6b, 0x20, 0x62, 0x72, 0x6f, 0x77, 0x6e, 0x20, 0x66, 0x6f, 
0x78, 0x20, 0x6a, 0x75, 0x6d, 0x70, 0x65, 0x64, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 
0x65, 0x20, 0x6c, 0x61, 0x7a, 0x79, 0x20, 0x64, 0x6f, 0x67, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 
0x71, 0x75, 0x69, 0x63, 0x6b, 0x20, 0x62, 0x72, 0x6f, 0x77, 0x6e, 0x20, 0x66, 0x6f, 0x78, 0x20, 
0x6a, 0x75, 0x6d, 0x70, 0x65, 0x64, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 
0x6c, 0x61, 0x7a, 0x79, 0x20, 0x64, 0x6f, 0x67, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x71, 0x75, 
0x69, 0x63, 0x6b, 0x20, 0x62, 0x72, 0x6f, 0x77, 0x6e, 0x20, 0x66, 0x6f, 0x78, 0x20, 0x6a, 0x75, 
0x6d, 0x70, 0x65, 0x64, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x61, 
0x7a, 0x79, 0x20, 0x64, 0x6f, 0x67, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x71, 0x75, 0x69, 0x63, 
0x6b, 0x20, 0x62, 0x72, 0x6f, 0x77, 0x6e, 0x20, 0x66, 0x6f, 0x78, 0x20, 0x6a, 0x75, 0x6d, 0x70, 
0x65, 0x64, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x61, 0x7a, 0x79, 
0x20, 0x64, 0x6f, 0x67, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x71, 0x75, 0x69, 0x63, 0x6b, 0x20, 
0x62, 0x72, 0x6f, 0x77, 0x6e, 0x20, 0x66, 0x6f, 0x78, 0x20, 0x6a, 0x75, 0x6d, 0x70, 0x65, 0x64, 
0x20, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x61, 0x7a, 0x79, 0x20, 0x64, 
0x6f, 0x67, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x71, 0x75, 0x69, 0x63, 0x6b, 0x20, 0x62, 0x72, 
0x6f, 0x77, 0x6e, 0x20, 0x66, 0x6f, 0x78, 0x20, 0x6a, 0x75, 0x6d, 0x70, 0x65, 0x64, 0x20, 0x6f, 
0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x61, 0x7a, 0x79, 0x20, 0x64, 0x6f, 0x67, 
0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x71, 0x75, 0x69, 0x63, 0x6b, 0x20, 0x62, 0x72, 0x6f, 0x77, 
0x6e, 0x20, 0x66, 0x6f, 0x78, 0x20, 0x6a, 0x75, 0x6d, 0x70, 0x65, 0x64, 0x20, 0x6f, 0x76, 0x65, 
0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x61, 0x7a, 0x79, 0x20, 0x64, 0x6f, 0x67, 0x2e, 0x20, 
0x54, 0x68, 0x65, 0x20, 0x71, 0x75, 0x69, 0x63, 0x6b, 0x20, 0x62, 0x72, 0x6f, 0x77, 0x6e, 0x20, 
0x66, 0x6f, 0x78, 0x20, 0x6a, 0x75, 0x6d, 0x70, 0x65, 0x64, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x20, 
0x74, 0x68, 0x65, 0x20, 0x6c, 0x61, 0x7a, 0x79, 0x20, 0x64, 0x6f, 0x67, 0x2e, 0x20, 0x54, 0x68, 
0x65, 0x20, 0x71, 0x75, 0x69, 0x63, 0x6b, 0x20, 0x62, 0x72, 0x6f, 0x77, 0x6e, 0x20, 0x66, 0x6f, 
0x78, 0x20, 0x6a, 0x75, 0x6d, 0x70, 0x65, 0x64, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 
0x65, 0x20, 0x6c, 0x61, 0x7a, 0x79, 0x20, 0x64, 0x6f, 0x67, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 
0x71, 0x75, 0x69, 0x63, 0x6b, 0x20, 0x62, 0x72, 0x6f, 0x77, 0x6e, 0x20, 0x66, 0x6f, 0x78, 0x20, 
0x6a, 0x75, 0x6d, 0x70, 0x65, 0x64, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 
0x6c, 0x61, 0x7a, 0x79, 0x20, 0x64, 0x6f, 0x67, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x71, 0x75
    }
};

const cryptoST_testVector_t OpenSSL_vector_4096enc =
{
    .name = "OpenSSL_vector_4096enc",
    .source = __BASE_FILE__ "(" BASE_LINE ")",
    .description = "OpenSSL vector 4096enc",
    .vector.length = 512,
    .vector.data = (DATA_CHAR[512]){ // plaintext (golden data)
0xc0, 0xf2, 0x32, 0x49, 0xb2, 0xcd, 0xb4, 0x7d, 0xba, 0x9b, 0x1c, 0x6c, 0xc5, 0x47, 0x4c, 0x11, 
0x92, 0xa2, 0x5b, 0x18, 0xef, 0xa0, 0x18, 0x27, 0x05, 0x94, 0xeb, 0xac, 0xf2, 0x95, 0xe3, 0x2e, 
0xfe, 0xf7, 0x43, 0xec, 0x42, 0x0a, 0x78, 0xe1, 0x70, 0x3b, 0x3b, 0x8d, 0x4e, 0xbd, 0xe7, 0x2b, 
0x39, 0xbf, 0x63, 0x9e, 0xec, 0x98, 0x7a, 0x8d, 0xe0, 0xb2, 0xf9, 0x39, 0xc0, 0x06, 0xd2, 0x64, 
0x5e, 0x5b, 0xc3, 0x51, 0x05, 0xd4, 0x62, 0x51, 0x33, 0x28, 0x25, 0x56, 0x7a, 0xab, 0xb6, 0x71, 
0xd4, 0xbe, 0x16, 0x56, 0x0d, 0x8a, 0x0d, 0x2d, 0xf2, 0xc9, 0xdb, 0x27, 0x1a, 0x11, 0x83, 0x4f, 
0x95, 0xff, 0xa2, 0x9c, 0x86, 0xd2, 0x39, 0xae, 0x62, 0xa9, 0xe2, 0x0a, 0x2b, 0x84, 0x1d, 0x65, 
0x80, 0x72, 0x38, 0x82, 0x7b, 0x49, 0xc5, 0x53, 0x77, 0xdf, 0x79, 0x22, 0x14, 0xbf, 0xd7, 0xd9, 
0x43, 0x6a, 0x9c, 0x70, 0x76, 0x96, 0x91, 0x59, 0xf2, 0x9e, 0x77, 0xc6, 0xe2, 0x79, 0x00, 0xb5, 
0x41, 0xd9, 0x67, 0x05, 0xaf, 0xdc, 0x43, 0x9f, 0xea, 0xc6, 0x08, 0xe1, 0xde, 0x35, 0x03, 0x6e, 
0x1f, 0x72, 0x64, 0xef, 0xa6, 0xc1, 0x5d, 0x74, 0xc0, 0xf7, 0x57, 0x36, 0x63, 0xb1, 0x08, 0xd7, 
0x49, 0x29, 0x74, 0x09, 0xe6, 0x80, 0x69, 0x63, 0x14, 0x14, 0xb9, 0xae, 0x20, 0x26, 0x26, 0xed, 
0xa7, 0xee, 0xf4, 0x1b, 0x76, 0xb0, 0xaf, 0x48, 0x61, 0x4b, 0x1c, 0x12, 0xaa, 0x49, 0x8f, 0x71, 
0x8e, 0x97, 0x1d, 0x1d, 0xa9, 0x3e, 0x44, 0xf3, 0xbc, 0xa2, 0x6d, 0x61, 0x49, 0x2b, 0xbc, 0xd8, 
0x47, 0xc7, 0xb4, 0x27, 0x71, 0xaf, 0x59, 0x03, 0x81, 0x65, 0x0f, 0xcc, 0x27, 0x32, 0x9e, 0xdb, 
0xb9, 0xad, 0x0d, 0x43, 0x9c, 0x0a, 0x9c, 0xa2, 0x29, 0xd0, 0x36, 0x6a, 0x4d, 0xb3, 0x9b, 0xcd, 
0x08, 0xcc, 0xbb, 0x2b, 0x6f, 0x6e, 0x0c, 0x63, 0x1c, 0x9a, 0x00, 0xf2, 0xd5, 0x37, 0xc0, 0xd6, 
0xfe, 0xf5, 0x44, 0xd3, 0x8e, 0xea, 0xe7, 0xa9, 0x32, 0x60, 0xb4, 0xab, 0x5e, 0x84, 0x63, 0xe4, 
0x0a, 0x1d, 0xf9, 0x5d, 0x04, 0x3a, 0xe8, 0xd2, 0xae, 0xcb, 0x20, 0x05, 0xb1, 0x64, 0x08, 0x68, 
0xab, 0x8b, 0xbb, 0xc3, 0x6a, 0x97, 0x16, 0x55, 0x0d, 0x44, 0x22, 0x1c, 0x54, 0x70, 0xdd, 0x27, 
0x8f, 0xcc, 0xc4, 0xc9, 0x95, 0x1e, 0x99, 0x1c, 0xa2, 0xb4, 0x27, 0x78, 0xbc, 0x86, 0x6d, 0x8d, 
0x4a, 0xcc, 0x1b, 0xf6, 0xbf, 0x6b, 0xfe, 0xdb, 0x2b, 0x63, 0x39, 0x58, 0xc8, 0x08, 0xc2, 0xa5, 
0xe8, 0x38, 0x7a, 0x84, 0x47, 0x2c, 0x53, 0x63, 0x90, 0xb3, 0xf3, 0xc5, 0xbf, 0x43, 0x62, 0x9b, 
0x2b, 0x60, 0x22, 0x52, 0x41, 0xf4, 0xaa, 0x78, 0x21, 0x75, 0x4b, 0x44, 0x06, 0x8e, 0x82, 0x6e, 
0x50, 0x3c, 0xef, 0xb9, 0xb5, 0x59, 0x24, 0x0b, 0x72, 0xf4, 0x52, 0xf2, 0x87, 0xd2, 0xb9, 0xcc, 
0xec, 0xa4, 0x58, 0x13, 0xb4, 0xe7, 0x4d, 0x6b, 0xac, 0x25, 0xf9, 0x0b, 0x4c, 0xd1, 0x17, 0x20, 
0x48, 0x45, 0x9c, 0xd4, 0x74, 0x15, 0xab, 0x06, 0x69, 0xe3, 0x99, 0xb8, 0x31, 0xf0, 0x7d, 0xcb, 
0xa5, 0x67, 0x60, 0x60, 0x20, 0x24, 0x77, 0x08, 0x5e, 0x69, 0x16, 0x28, 0xf2, 0xa3, 0x8a, 0xde, 
0x80, 0x78, 0x62, 0x98, 0xf5, 0xe0, 0xab, 0x36, 0x80, 0xb3, 0xf4, 0x3c, 0x2b, 0x48, 0xf8, 0x84, 
0x57, 0x8f, 0x80, 0xd3, 0xbf, 0xb8, 0xb7, 0xec, 0x5c, 0x9f, 0xf7, 0xfc, 0x25, 0x66, 0x99, 0x57, 
0x6e, 0xaa, 0x8d, 0xf6, 0xac, 0x29, 0x44, 0x14, 0xa0, 0xc8, 0x7f, 0x6a, 0xe6, 0xa6, 0x38, 0x65, 
0xdf, 0xd9, 0x20, 0x30, 0x64, 0x9a, 0x95, 0xe2, 0x0d, 0x9a, 0x4a, 0x84, 0x8e, 0x87, 0x5d, 0xfe
    }
};
#endif //!defined NO_RSA

int techniqueList[] = 
{
    ET_AES_128,
#if !defined(NO_AES_192)
    ET_AES_192,
#endif
#if !defined(NO_AES_256)
    ET_AES_256,
#endif
#if !defined(__SAML11E16A__) // compiler pre-defined
    ET_AES_GCM, 
    ET_AES_CCM,
#endif
    ET_DES3,
#if !defined(NO_SHA)
    ET_SHA_1,  /* SHA1 */
#endif
#if (!defined(NO_SHA224) && !defined(WOLFSSL_MICROCHIP_PIC32MZ))
    ET_SHA_224,
#endif
    ET_SHA_256,
#if defined(WOLFSSL_SHA384)
    ET_SHA_384,
#endif
#if defined(WOLFSSL_SHA512)
    ET_SHA_512,
#endif
#if !defined(NO_RSA)
    ET_PK_RSA_EXPTMOD,
    //ET_PK_RSA_SIGN,
    //ET_PK_RSA_VERIFY,
#endif
    ~0,
#if !defined(NO_MD5)
    ET_MD5,
#endif
    ET_SHA3_224,//TODO implement SHA3
    ET_SHA3_256,
    ET_SHA3_384,
    ET_SHA3_512,

};
int modeList[] = 
{
    EM_CBC,//first before ECB because it simplified DES conditions
    EM_ECB,
#if !defined(__SAML11E16A__) // compiler pre-defined
    EM_CFB,
    EM_OFB, 
    EM_CTR,
//    EM_GCM,
    EM_XTS,
    //EM_CMAC,         
#endif
    ~0,
};

int rsaIdx = 0;

static cryptoST_testDetail_t test_item =
{
    .technique = ET_AES_128,
    .mode = EM_CBC,
    .recommendedRepetitions = 100,

    .source = __BASE_FILE__ "(" BASE_LINE ")",
    .pedigree = "Blocks of null data",
    .rawData = &satcZ,
    .io.sym.in.key.data = (unsigned char*)"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
    .io.sym.in.key.length = 16,        
    .io.sym.out.cipher = {
        .data = ((void*)0), // fill in later
        .length = 0,
    },
    .io.hash.out.hash.data = NULL,//sramBuffer, 
    .io.hash.out.hash.length = 0,
};

/*************************************************************
 * Helper functions
 *************************************************************/

/*************************************************************
 * API handlers
 *************************************************************/
static const char * openData_func(void)
{
    /* Allocate the largest required buffer now, because there
     * is no provision for return errors in first() or next().
     * If we can't get it now, we won't get it later, either.
     *  */
    satcZ.vector.data = cryptoSTE_malloc(ZERO_MAX);
    if (satcZ.vector.data)
    {
        memset((uint8_t*)satcZ.vector.data,0,ZERO_MAX);
        return NULL;
    }
    else return 
        DATA_PACKAGE_NAME " malloc error " __BASE_FILE__ "(" BASE_LINE ")";
}

static const char * closeData_func(void)
{
    if (satcZ.vector.data) 
        cryptoSTE_free((void*)satcZ.vector.data);
    satcZ.vector.data = NULL;
    return NULL;
}

int techniqueIter = 0;
int modeIter = 0;
int lenIter = 0;
//static unsigned int zero_test = 0;

#define test_item_count 1 //(sizeof(test_item)/sizeof(cryptoST_testDetail_t))
static const cryptoST_testDetail_t * nextTest(const cryptoST_testDetail_t * old)
{
    // Need to check if "old" is out of bounds.
    //state machine states for AES: 16, 32, 128, 10k
    //state machine states for DES:  8, 16, 128, 10k
    //state machine states for SHA: 32, 64, 128, 256, 10k
    int msg_len_list[10] = {0};
    int once = 1;
    if ((old != &test_item)
            || (ET_NONE == old->technique))
        ;
    else
    {
        // If we are not already to the magic block, move forward
        //if (old->rawData != &satcZ)
        //{
        //    printf("++old;\r\n");
        //    old->rawData = &satcZ;
        //    ++old; // repurpose: this is now "new"
        //}
        //else
        //{
        //    printf("old->rawData == &satcZ\r\n");
        //}
        // If we are now at the magic block, generate a dataset
        //if (old->rawData == &satcZ)
        //{
            //printf("outside once loop\r\n");
            while(once)
            {  //future: switch case
                //printf("techniqueIter %d\r\n", techniqueIter);
                //printf("entered NextTest once loop\r\n");
                int inc_technique_not_mode = 0;
                test_item.io.sym.in.key.data = (unsigned char*)
                "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
                //printf("key data %08X\r\n", (unsigned int)test_item.io.sym.in.key.data);
                test_item.io.sym.in.ivNonce.data = (unsigned char*)
                "0123456789abcdef0123456789abcdef";
                //printf("init data %08X\r\n", (unsigned int)test_item.io.sym.in.ivNonce.data);
                if(~0 == modeList[modeIter])//reached end of modes, go to next technique
                {
                    modeIter = 0;
                    techniqueIter++;
                }
                if(~0 == techniqueList[techniqueIter])
                {
                    return NULL;//reached end of algorithms to test
                }
                //assign
              /*switch(techniqueList[techniqueIter])
                {
                    case(ET_AES_192):
                        if(modeList[modeIter] == EM_XTS)
                        {
                            modeIter++;//skip nonexistent 192 XTS 
                            continue;// evaluate the new mode/technique in the state machine again
                        }
                    case(ET_AES_128):
                    case(ET_AES_256):
                //change if-else to switch?  the fallthrough is not always welcome.        
                        
                }*/
                if(techniqueList[techniqueIter] == ET_AES_128 ||
                   techniqueList[techniqueIter] == ET_AES_192 ||
                   techniqueList[techniqueIter] == ET_AES_256)
                {
                    if(techniqueList[techniqueIter] == ET_AES_192 &&
                       modeList[modeIter] == EM_XTS
                       )
                    {
                       modeIter++;//skip nonexistent 192 XTS 
                       continue;// evaluate the new mode/technique in the state machine again
                    }
                    if(techniqueList[techniqueIter] == ET_AES_128)
                    {
                        test_item.io.sym.in.key.length = 16;
                    } 
                    else if(techniqueList[techniqueIter] == ET_AES_192)
                    {
                        test_item.io.sym.in.key.length = 24;
                    }     
                    else if(techniqueList[techniqueIter] == ET_AES_256)
                    {
                        test_item.io.sym.in.key.length = 32;
                    }               
                    test_item.io.sym.in.ivNonce.data = (unsigned char*)
                            "0123456789abcdef0123456789abcdef";
                    test_item.io.sym.in.ivNonce.length = 16;
                    if(modeList[modeIter] == EM_XTS)
                    { //xts has two keys
                        test_item.io.sym.in.key.length = 
                                test_item.io.sym.in.key.length*2;
                    }
                    test_item.technique = techniqueList[techniqueIter];
                    test_item.mode = modeList[modeIter];
                    
                } 
                else if(techniqueList[techniqueIter] == ET_AES_GCM)
                {
                    //below: hack to get the keylengths from an existing iteration
                    test_item.io.sym.in.key.length = 16 + 8*modeIter;
                    test_item.io.sym.in.ivNonce.length = 12;
                    test_item.io.sym.in.additionalAuthData.length = 16;
                    test_item.technique = techniqueList[techniqueIter];
                    test_item.mode = EM_NONE;
                    if(modeIter >= 3)
                    {//end the GCM portion after doing 128, 192, and 256 bit blocks
                        modeIter++;
                        continue;
                    }
                }
                else if(techniqueList[techniqueIter] == ET_AES_CCM)
                {
                    test_item.io.sym.in.key.length = 16 + 8*modeIter;//128,192,256
                    test_item.io.sym.in.key.data = (unsigned char*)
                    "\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF"//this line from a text vector
                    "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F";//this line is bogus
                    test_item.technique = techniqueList[techniqueIter];
                    test_item.mode = EM_NONE;
                    test_item.io.sym.in.additionalAuthData.length = 8;
                    test_item.io.sym.in.additionalAuthData.data = (unsigned char*)
                    "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F"
                    "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F"
                    "\x20";
                    test_item.io.sym.in.ivNonce.length = 13;
                    test_item.io.sym.in.ivNonce.data = (unsigned char*)
                    "\x00\x00\x00\x03\x02\x01\x00\xA0\xA1\xA2\xA3\xA4\xA5";
                    test_item.io.sym.out.cipher.length = 0;//31-8;
                    test_item.io.sym.out.cipher.data = NULL;//&sramBuffer[8];//&PV1_cipher[8];
                    test_item.io.sym.out.tag.length = 8;//39-31;
                    test_item.io.sym.out.tag.data = &sramBuffer[0];

                    if(modeIter >= 1)
                    {//end the CCM portion after doing 128 bit keys
                        modeIter++;
                        continue;
                    }
                }
                else if(techniqueList[techniqueIter] == ET_DES3)
                {
                    test_item.io.sym.in.key.length = 24;
                    test_item.io.sym.in.ivNonce.data = (unsigned char*)
                            "0123456789abcdef0123456789abcdef";
                    test_item.io.sym.in.ivNonce.length = 8;
                    test_item.io.sym.out.cipher.data = NULL;//don't check golden
    
                    if(
#if defined(WOLFSSL_DES_ECB)
                            EM_ECB == modeList[modeIter]) || 
#endif
                            EM_CBC == modeList[modeIter])
                    {
                        test_item.technique = techniqueList[techniqueIter];
                        test_item.mode = modeList[modeIter]; 
                    }
                    else
                    {
                        modeIter = 0;
                        techniqueIter++;
                        continue;// evaluate the new mode/technique in the state machine again
                    }
                }
                else if(ET_MD5      == techniqueList[techniqueIter] ||
                        ET_SHA_1    == techniqueList[techniqueIter] ||   /* SHA1 */
                        ET_SHA_224  == techniqueList[techniqueIter] ||
                        ET_SHA_256  == techniqueList[techniqueIter] ||
                        ET_SHA_384  == techniqueList[techniqueIter] ||
                        ET_SHA_512  == techniqueList[techniqueIter]
#if defined(WOLFSSL_SHA3) 
                        ||
                        ET_SHA3_224 == techniqueList[techniqueIter] ||
                        ET_SHA3_256 == techniqueList[techniqueIter] ||
                        ET_SHA3_384 == techniqueList[techniqueIter] ||
                        ET_SHA3_512 == techniqueList[techniqueIter]*/
#endif                        
                        )
                {
                    test_item.technique = techniqueList[techniqueIter];
                    test_item.mode = EM_NONE;
                }
#if !defined(NO_RSA)
                else if(ET_PK_RSA_SIGN == techniqueList[techniqueIter] ||
                        //ET_PK_RSA_VERIFY == techniqueList[techniqueIter] ||
                        ET_PK_RSA_EXPTMOD == techniqueList[techniqueIter])    
                {
                    if(lenIter == 0 && ET_PK_RSA_EXPTMOD == techniqueList[techniqueIter])
                    {
                        //printf("1024: techniqueIter is %d in nextTest public key test item assignments\r\n", techniqueIter);
                        test_item.recommendedRepetitions = 10;
                        test_item.source = __BASE_FILE__ "(" BASE_LINE ")";
                        test_item.pedigree = "OpenSSL vector 1024";
                        test_item.rawData = &OpenSSL_vector_1024;
                        test_item.io.rsav.in.n = &n1024;
                        test_item.io.rsav.in.d = &d1024;
                        test_item.io.rsav.in.em = &c1024;
                        test_item.io.rsav.in.e = 0;//&e1024;
                        test_item.io.rsav.in.hashmode = ET_NONE;
                    }
                    /*if(lenIter == 0 && ET_PK_RSA_SIGN == techniqueList[techniqueIter])
                    {
                        test_item.technique = ET_PK_RSA_SIGN,
                        test_item.mode = EM_NONE,
                        test_item.recommendedRepetitions = 5,

                        test_item.source = __BASE_FILE__ "(" BASE_LINE ")",
                        test_item.pedigree = "OpenSSL vector 1024",
                        test_item.rawData = &OpenSSL_vector_1024;
                        test_item.io.rsas.in.der = &der1024;
                        test_item.io.rsas.out.signature = &sig1024;
                        test_item.io.rsas.in.hashmode = ET_SHA_256;
                    }*/
                    //if(lenIter == 0 && ET_PK_RSA_VERIFY == techniqueList[techniqueIter])
                    //{
                    //    //printf("1024: techniqueIter is %d in nextTest public key test item assignments\r\n", techniqueIter);
                    //    test_item.recommendedRepetitions = 10;
                    //    test_item.source = __BASE_FILE__ "(" BASE_LINE ")";
                    //    test_item.pedigree = "OpenSSL vector 1024";
                    //    test_item.rawData = &OpenSSL_vector_1024;
                    //    test_item.io.rsav.in.n = &n1024;
                    //    test_item.io.rsav.in.em = &(OpenSSL_vector_1024.vector);
                    //    test_item.io.rsav.in.e = &e1024;
                    //    test_item.io.rsav.in.hashmode = ET_SHA_256;
                    //}
                    /*if(lenIter == 1 && ET_PK_RSA_SIGN == techniqueList[techniqueIter])
                    {
                        test_item.technique = ET_PK_RSA_SIGN,
                        test_item.mode = EM_NONE,
                        test_item.recommendedRepetitions = 5,

                        test_item.source = __BASE_FILE__ "(" BASE_LINE ")",
                        test_item.pedigree = "OpenSSL vector 2048",
                        test_item.rawData = &RSASP1_256_2048_7099;
                        test_item.io.rsas.in.der = &der2048;
                        test_item.io.rsas.out.signature = &sig2048;
                        test_item.io.rsas.in.hashmode = ET_SHA_256;
                    }*/
                    //if(lenIter == 1 && ET_PK_RSA_VERIFY == techniqueList[techniqueIter])
                    //{
                    //    test_item.technique = ET_PK_RSA_VERIFY,
                    //    test_item.mode = EM_NONE,
                    //    test_item.recommendedRepetitions = 5,

                    //    test_item.pedigree = "OpenSSL vector 2048",
                    //    test_item.rawData = &RSASP1_256_2048_7099;
                    //    test_item.io.rsav.in.n = &n1024;
                    //    test_item.io.rsav.in.em = &sig2048;
                    //    test_item.io.rsav.in.e = &e2048;
                    //    test_item.io.rsav.in.hashmode = ET_SHA_256;
                    //}
                    if(lenIter == 1 && ET_PK_RSA_EXPTMOD == techniqueList[techniqueIter])
                    {
                        //printf("1024: techniqueIter is %d in nextTest public key test item assignments\r\n", techniqueIter);
                        test_item.recommendedRepetitions = 10;
                        test_item.source = __BASE_FILE__ "(" BASE_LINE ")";
                        test_item.pedigree = "OpenSSL vector 1024enc";
                        test_item.rawData = &OpenSSL_vector_1024enc;
                        test_item.io.rsav.in.n = &n1024;
                        test_item.io.rsav.in.d = &e1024;
                        test_item.io.rsav.in.em = &OpenSSL_vector_1024.vector;
                        test_item.io.rsav.in.e = 0;//&e1024;
                        test_item.io.rsav.in.hashmode = ET_NONE;
                    }
                    else if(lenIter == 2 && ET_PK_RSA_EXPTMOD == techniqueList[techniqueIter])
                    {
                        //printf("2048: techniqueIter is %d in nextTest public key test item assignments\r\n", techniqueIter);
                        test_item.recommendedRepetitions = 10;
                        test_item.source = __BASE_FILE__ "(" BASE_LINE ")";
                        test_item.pedigree = "NIST suite RSA2SP1 (CAVS16p1)";
                        test_item.rawData = &RSASP1_256_2048_7099;//in included header
                        test_item.io.rsav.in.n = &cavs16p1_2048n;
                        test_item.io.rsav.in.d = &cavs16p1_2048d;
                        //printf("n length %d ptr %p 1stbyte %02X\r\n", test_item.io.rsav.in.n->length, test_item.io.rsav.in.n->data, test_item.io.rsav.in.n->data[0]);
                        //printf("d length %d ptr %p 1stbyte %02X\r\n", test_item.io.rsav.in.d->length, test_item.io.rsav.in.d->data, test_item.io.rsav.in.d->data[0]);
                        test_item.io.rsav.in.em = &cavs16p1_2048ct;
                        //printf("em length %d ptr %p 1stbyte %02X\r\n", test_item.io.rsav.in.em->length, test_item.io.rsav.in.em->data, test_item.io.rsav.in.em->data[0]);
                        test_item.io.rsav.in.e = 0;//&e2048;
                        test_item.io.rsav.in.hashmode = ET_NONE;
                    }
                    /*if(lenIter == 2 && ET_PK_RSA_SIGN == techniqueList[techniqueIter])
                    {
                        test_item.technique = ET_PK_RSA_SIGN,
                        test_item.mode = EM_NONE,
                        test_item.recommendedRepetitions = 5,

                        test_item.source = __BASE_FILE__ "(" BASE_LINE ")",
                        test_item.pedigree = "OpenSSL vector 4096",
                        test_item.rawData = &OpenSSL_vector_4096;
                        test_item.io.rsas.in.der = &der4096;
                        test_item.io.rsas.out.signature = &sig4096;
                        test_item.io.rsas.in.hashmode = ET_SHA_256;
                    }
                    */
                    //if(lenIter == 2 && ET_PK_RSA_VERIFY == techniqueList[techniqueIter])
                    //{
                    //    test_item.recommendedRepetitions = 10;
                    //    test_item.source = __BASE_FILE__ "(" BASE_LINE ")";
                    //    test_item.pedigree = "OpenSSL vector 4096";
                    //    test_item.rawData = &OpenSSL_vector_4096;
                    //    test_item.io.rsav.in.n = &n4096;
                    //    test_item.io.rsav.in.em = &sig4096;
                    //    test_item.io.rsav.in.e = &e4096;
                    //    test_item.io.rsav.in.hashmode = ET_SHA_256;
                    //}
                    else if(lenIter == 3 && ET_PK_RSA_EXPTMOD == techniqueList[techniqueIter])
                    {
                        //printf("2048: techniqueIter is %d in nextTest public key test item assignments\r\n", techniqueIter);
                        test_item.recommendedRepetitions = 10;
                        test_item.source = __BASE_FILE__ "(" BASE_LINE ")";
                        test_item.pedigree = "NIST suite RSA2SP1 (CAVS16p1)";
                        test_item.rawData = &RSASP1_256_2048_7099enc;//in included header
                        test_item.io.rsav.in.n = &cavs16p1_2048n;
                        test_item.io.rsav.in.d = &e2048;
                        //printf("n length %d ptr %p 1stbyte %02X\r\n", test_item.io.rsav.in.n->length, test_item.io.rsav.in.n->data, test_item.io.rsav.in.n->data[0]);
                        //printf("d length %d ptr %p 1stbyte %02X\r\n", test_item.io.rsav.in.d->length, test_item.io.rsav.in.d->data, test_item.io.rsav.in.d->data[0]);
                        test_item.io.rsav.in.em = &RSASP1_256_2048_7099.vector;
                        //printf("em length %d ptr %p 1stbyte %02X\r\n", test_item.io.rsav.in.em->length, test_item.io.rsav.in.em->data, test_item.io.rsav.in.em->data[0]);
                        test_item.io.rsav.in.e = 0;//&e2048;
                        test_item.io.rsav.in.hashmode = ET_NONE;
                    }
                    /*else if(lenIter == 4 && ET_PK_RSA_EXPTMOD == techniqueList[techniqueIter])
                    {
                        //printf("4096: techniqueIter is %d in nextTest public key test item assignments\r\n", techniqueIter);
                        test_item.recommendedRepetitions = 10;
                        test_item.source = __BASE_FILE__ "(" BASE_LINE ")";
                        test_item.pedigree = "OpenSSL vector 4096";
                        test_item.rawData = &OpenSSL_vector_4096;
                        test_item.io.rsav.in.n = &n4096;
                        test_item.io.rsav.in.d = &d4096;
                        test_item.io.rsav.in.em = &c4096;
                        test_item.io.rsav.in.e = 0;//&e4096;
                        test_item.io.rsav.in.hashmode = ET_NONE;
                    }
                    else if(lenIter == 5 && ET_PK_RSA_EXPTMOD == techniqueList[techniqueIter])
                    {
                        //printf("4096: techniqueIter is %d in nextTest public key test item assignments\r\n", techniqueIter);
                        test_item.recommendedRepetitions = 10;
                        test_item.source = __BASE_FILE__ "(" BASE_LINE ")";
                        test_item.pedigree = "OpenSSL vector 4096enc";
                        test_item.rawData = &OpenSSL_vector_4096enc;
                        test_item.io.rsav.in.n = &n4096;
                        test_item.io.rsav.in.d = &e4096;
                        test_item.io.rsav.in.em = &OpenSSL_vector_4096.vector;
                        test_item.io.rsav.in.e = 0;//&e4096;
                        test_item.io.rsav.in.hashmode = ET_NONE;
                    }
                    */
                    test_item.technique = techniqueList[techniqueIter];
                    test_item.mode = EM_NONE;
                    inc_technique_not_mode = 1;
                }
#endif
                else//add ECC, CHACHA, POLY, etc in more cases here
                {
                    //while(1);
                    if(~0 == techniqueList[techniqueIter])
                    {
                        printf("found techniqueList terminator\r\n");
                        return NULL;
                    }
                }
                //printf("before msg_len_list assign\r\n");
                if(ET_AES_128 == test_item.technique ||
                   ET_AES_192 == test_item.technique ||
                   ET_AES_256 == test_item.technique ||
                   ET_AES_GCM == test_item.technique ||
                   ET_AES_CCM == test_item.technique)
                {
                    //msg_len_list[10] = (int[]){16, 32, 128, ZERO_MAX, 0,};//couldn't get this to work
                    msg_len_list[0] = 16; // number of bytes in the 0th, 1st, etc test to generate
                    msg_len_list[1] = 32;
                    msg_len_list[2] = 128; // (ALIGN4 const uint8_t[]){0x61, 0x62, 0x63} style assign
                    msg_len_list[3] = ZERO_MAX;
                    msg_len_list[4] = 0; // terminator
                    if(ET_AES_CCM == test_item.technique)
                    {
                        test_item.io.sym.out.cipher.length = 0;//msg_len_list[lenIter];
                        test_item.io.sym.out.cipher.data = NULL;//don't check golden
                        test_item.io.sym.out.tag.data = NULL;//don't check golden
                    }
                }
                else if(ET_DES3 == test_item.technique)
                {
                   msg_len_list[0] = 8;
                   msg_len_list[1] = 16;
                   msg_len_list[2] = 128;
                   msg_len_list[3] = ZERO_MAX;
                   msg_len_list[4] = 0;
                }
                else if(                     
                        ET_MD5 == test_item.technique ||
                        ET_SHA_1 == test_item.technique ||     /* SHA1 */
                        ET_SHA_224 == test_item.technique ||
                        ET_SHA_256 == test_item.technique ||
                        ET_SHA_384 == test_item.technique ||
                        ET_SHA_512 == test_item.technique 
#if defined(WOLFSSL_SHA3)                        
                        ||
                        ET_SHA3_224 == test_item.technique ||
                        ET_SHA3_256 == test_item.technique ||
                        ET_SHA3_384 == test_item.technique ||
                        ET_SHA3_512 == test_item.technique
#endif
                        )
                {
                    msg_len_list[0] = 32;
                    msg_len_list[1] = 64;
                    msg_len_list[2] = 128;
                    msg_len_list[3] = 256;
                    msg_len_list[4] = ZERO_MAX;
                    msg_len_list[5] = 0;
                    // Let wolfCrypt compute the golden answer
                    if(ET_MD5 == test_item.technique)
                    {
                        test_item.io.hash.out.hash.length = 128/8;
                        //wc_Md5Hash(satcZ.vector.data,// uncomment and fix
                        //   msg_len_list[lenIter],
                        //   (uint8_t*)old->io.hash.out.hash.data);
                    }
                    //printf("msg_len_list[lenIter] %d", msg_len_list[lenIter]);
                    if(ET_SHA_1 == test_item.technique)
                    {
                        test_item.io.hash.out.hash.length = 160/8;
                        //DLS uncomment: on SAML21 there was a crash
                        //when Final() called InitSha(), I guess to clear buffers
                        //InitSha() has several implementations base on #if & hw
                        //wc_ShaHash(satcZ.vector.data,
                        //   msg_len_list[lenIter],
                        //   (uint8_t*)old->io.hash.out.hash.data);
                    }
                    if(ET_SHA_224 == test_item.technique)
                    {
                        test_item.io.hash.out.hash.length = 224/8;
                        
                        //wc_Sha224Hash(satcZ.vector.data,
                        //   msg_len_list[lenIter],
                        //   (uint8_t*)old->io.hash.out.hash.data);
                    }
                    if(ET_SHA_256 == test_item.technique)
                    {
                        test_item.io.hash.out.hash.length = 256/8;
                        //wc_Sha256Hash(satcZ.vector.data,
                        //   msg_len_list[lenIter],
                        //   (uint8_t*)old->io.hash.out.hash.data);
                    }
#if defined(WOLFSSL_SHA384)
                    if(ET_SHA_384 == test_item.technique)
                    {
                        test_item.io.hash.out.hash.length = 384/8;
                        wc_Sha384Hash(satcZ.vector.data,
                           msg_len_list[lenIter],
                           (uint8_t*)old->io.hash.out.hash.data);
                    }
#endif
#if defined(WOLFSSL_SHA512)
                    if(ET_SHA_512 == test_item.technique)
                    {
                        test_item.io.hash.out.hash.length = 512/8;
                        wc_Sha512Hash(satcZ.vector.data,
                           msg_len_list[lenIter],
                           (uint8_t*)old->io.hash.out.hash.data);
                    }
#endif
#if defined(WOLFSSL_SHA3)
                    if(ET_SHA3_224 == test_item.technique)
                    {
                        test_item.io.hash.out.hash.length = 224/8;
                        wc_Sha3_224Hash(satcZ.vector.data,
                           msg_len_list[lenIter],
                           (uint8_t*)old->io.hash.out.hash.data);
                    }
                    if(ET_SHA3_256 == test_item.technique)
                    {
                        test_item.io.hash.out.hash.length = 256/8;
                        wc_Sha3_256Hash(satcZ.vector.data,
                           msg_len_list[lenIter],
                           (uint8_t*)old->io.hash.out.hash.data);
                    }
                    if(ET_SHA3_384 == test_item.technique)
                    {
                        test_item.io.hash.out.hash.length = 384/8;
                        wc_Sha3_384Hash(satcZ.vector.data,
                           msg_len_list[lenIter],
                           (uint8_t*)old->io.hash.out.hash.data);
                    }
                    if(ET_SHA3_512 == test_item.technique)
                    {
                        test_item.io.hash.out.hash.length = 512/8;
                        wc_Sha3_512Hash(satcZ.vector.data,
                           msg_len_list[lenIter],
                           (uint8_t*)old->io.hash.out.hash.data);
                    }
#endif
                    inc_technique_not_mode = 1;
                    test_item.io.hash.out.hash.data = NULL;
                } 
                else if(ET_PK_RSA_EXPTMOD == techniqueList[techniqueIter])
                {
                    //rsaIdx++;                    
                    msg_len_list[0] = 128;
                    msg_len_list[1] = 128;
                    msg_len_list[2] = 256;
                    msg_len_list[3] = 256;
                    //msg_len_list[4] = 512;
                    //msg_len_list[5] = 512;
                    //msg_len_list[6] = 0;
                    msg_len_list[4] = 0;
                    //printf("msg len %d assigned for rsa enc/dec\r\n", msg_len_list[lenIter]);
                }
                //else if(ET_PK_RSA_SIGN == techniqueList[techniqueIter]) 
                //{
                    //rsaIdx++;                    
                    //msg_len_list[0] = 128;
                    //msg_len_list[1] = 256;
                    //msg_len_list[2] = 512;
                    //msg_len_list[3] = 0;
                //    msg_len_list[0] = 0;
                    //printf("msg len %d assigned for rsa sign\r\n", msg_len_list[lenIter]);
                //}
                //else if(ET_PK_RSA_VERIFY == techniqueList[techniqueIter]) 
                //{
                //    //rsaIdx++;                    
                //    msg_len_list[0] = 128;
                //    msg_len_list[1] = 256;
                //    msg_len_list[2] = 512;
                //    msg_len_list[3] = 0;
                //    //printf("msg len %d assigned for rsa verify\r\n", msg_len_list[lenIter]);
                //} 
                //printf("test_item.io.rsas.out.signature->length %d before satcZ assign\r\n",
                //        test_item.io.rsas.out.signature->length);
                satcZ.vector.length = msg_len_list[lenIter];
                //printf("test_item.io.rsas.out.signature->length %d after satcZ assign\r\n",
                //        test_item.io.rsas.out.signature->length);
                if(0 == inc_technique_not_mode)
                {
                    test_item.io.sym.out.cipher.length = 0;
                }
                //printf("msg len : %d\r\n", satcZ.vector.length);
                if (0 == msg_len_list[lenIter])
                {
                    //printf("0 == msg_len_list[lenIter]\r\n");
                    if(/*3 == lenIter && */(~0 == techniqueList[techniqueIter]))
                    {//warning, special case: finished with last alg. to test
                        //when adding algs, fix this
                        return NULL;
                    }
                    lenIter = 0;// move msgList in here?
                    if(0 == inc_technique_not_mode)
                    {//aes and des need to step modes, then techniques
                        modeIter++;
                    }
                    else
                    {//hashes need to step techniques (they don't have modes)
                        //printf("techniqueIter++\r\n");
                        techniqueIter++;
                    }
                    //printf("continue\r\n");
                    continue;
                }
                else
                {
                    //printf("lenIter++\r\n");
                    lenIter++;
                }

                once = 0;
            }//while(once)
            
        //}
        //printf("techniqueIter %d modeIter %d lenIter %d\r\n", 
        //        techniqueIter, modeIter, lenIter);
        //printf("returning old %p\r\n", old);
        //printf("with test_item.io.rsas.out.signature->length = %d\r\n", 
        //        test_item.io.rsas.out.signature->length);
                        
        return old;
    }
    //printf("returning NULL in msg size test\r\n");
    return NULL;
}

static const cryptoST_testDetail_t * firstTest(void)
{
    // Assume that #1 is not dynamically built
    modeIter = 0;
    techniqueIter = 0;
    lenIter = 0;
    if (satcZ.vector.data)
    {
        return nextTest(&test_item);
    }
    
    // If we get here the data vector is not initialized correctly
    // (e.g., the malloc failed), but main kept going.
    __conditional_software_breakpoint(0);
    return NULL;
}

/*************************************************************
 * Declaration of the test manager API
 * Obligatory entry points for executing a test
 *************************************************************/
cryptoST_testAPI_t const microchip_all_msgSize =
{
    .name = DATA_PACKAGE_NAME,
    .openData = openData_func,
    .firstTest = firstTest,
    .nextTest = nextTest,
    .closeData = closeData_func,
};
